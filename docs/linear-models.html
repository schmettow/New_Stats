<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>New statistics for the design researcher</title>
  <meta name="description" content="A statistics book for designers, human factors specialists, UX researchers, applied psychologists and everyone else who works hard to make this world a better place.">
  <meta name="generator" content="bookdown 0.7 and GitBook 2.6.7">

  <meta property="og:title" content="New statistics for the design researcher" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="A statistics book for designers, human factors specialists, UX researchers, applied psychologists and everyone else who works hard to make this world a better place." />
  <meta name="github-repo" content="schmettow/New_Stats" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="New statistics for the design researcher" />
  
  <meta name="twitter:description" content="A statistics book for designers, human factors specialists, UX researchers, applied psychologists and everyone else who works hard to make this world a better place." />
  

<meta name="author" content="Martin Schmettow">


<meta name="date" content="2018-11-01">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="getting-started-r.html">
<link rel="next" href="multilevel-models.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i><b>1</b> Introduction</a><ul>
<li class="chapter" data-level="1.1" data-path="index.html"><a href="index.html#whom-this-book-is-for"><i class="fa fa-check"></i><b>1.1</b> Whom this book is for</a><ul>
<li class="chapter" data-level="1.1.1" data-path="index.html"><a href="index.html#the-empirical-design-researcher"><i class="fa fa-check"></i><b>1.1.1</b> The empirical design researcher</a></li>
<li class="chapter" data-level="1.1.2" data-path="index.html"><a href="index.html#the-experimentalist"><i class="fa fa-check"></i><b>1.1.2</b> The experimentalist</a></li>
<li class="chapter" data-level="1.1.3" data-path="index.html"><a href="index.html#the-applied-researcher"><i class="fa fa-check"></i><b>1.1.3</b> The applied researcher</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="index.html"><a href="index.html#assumptions"><i class="fa fa-check"></i><b>1.2</b> Assumptions</a></li>
<li class="chapter" data-level="1.3" data-path="index.html"><a href="index.html#how-to-read-this-book"><i class="fa fa-check"></i><b>1.3</b> How to read this book</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="design-research.html"><a href="design-research.html"><i class="fa fa-check"></i><b>2</b> Elements of quantitative design research</a><ul>
<li class="chapter" data-level="2.1" data-path="design-research.html"><a href="design-research.html#studies"><i class="fa fa-check"></i><b>2.1</b> Studies</a></li>
<li class="chapter" data-level="2.2" data-path="design-research.html"><a href="design-research.html#observations-and-measurestbc"><i class="fa fa-check"></i><b>2.2</b> Observations and measures[TBC]</a><ul>
<li class="chapter" data-level="2.2.1" data-path="design-research.html"><a href="design-research.html#interaction-sequences"><i class="fa fa-check"></i><b>2.2.1</b> Interaction sequences</a></li>
<li class="chapter" data-level="2.2.2" data-path="design-research.html"><a href="design-research.html#performance-measures"><i class="fa fa-check"></i><b>2.2.2</b> performance measures</a></li>
<li class="chapter" data-level="2.2.3" data-path="design-research.html"><a href="design-research.html#experience-tbd"><i class="fa fa-check"></i><b>2.2.3</b> experience [TBD]</a></li>
<li class="chapter" data-level="2.2.4" data-path="design-research.html"><a href="design-research.html#design-features-tbd"><i class="fa fa-check"></i><b>2.2.4</b> design features [TBD]</a></li>
<li class="chapter" data-level="2.2.5" data-path="design-research.html"><a href="design-research.html#the-human-factor-tbd"><i class="fa fa-check"></i><b>2.2.5</b> the human factor [TBD]</a></li>
<li class="chapter" data-level="2.2.6" data-path="design-research.html"><a href="design-research.html#situations-tbd"><i class="fa fa-check"></i><b>2.2.6</b> situations [TBD]</a></li>
</ul></li>
<li class="chapter" data-level="2.3" data-path="design-research.html"><a href="design-research.html#decision_making"><i class="fa fa-check"></i><b>2.3</b> Decision making under uncertainty</a><ul>
<li class="chapter" data-level="2.3.1" data-path="design-research.html"><a href="design-research.html#measuring-uncertainty"><i class="fa fa-check"></i><b>2.3.1</b> Measuring uncertainty</a></li>
<li class="chapter" data-level="2.3.2" data-path="design-research.html"><a href="design-research.html#betting-on-designs"><i class="fa fa-check"></i><b>2.3.2</b> Betting on designs</a></li>
<li class="chapter" data-level="2.3.3" data-path="design-research.html"><a href="design-research.html#case-e-commerce-ab"><i class="fa fa-check"></i><b>2.3.3</b> Case: e-commerce A/B</a></li>
<li class="chapter" data-level="2.3.4" data-path="design-research.html"><a href="design-research.html#case99"><i class="fa fa-check"></i><b>2.3.4</b> Case: 99 seconds</a></li>
<li class="chapter" data-level="2.3.5" data-path="design-research.html"><a href="design-research.html#prior-information"><i class="fa fa-check"></i><b>2.3.5</b> Prior information</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html"><i class="fa fa-check"></i><b>3</b> Elements of Bayesian statistics</a><ul>
<li class="chapter" data-level="3.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#descriptive-statistics"><i class="fa fa-check"></i><b>3.1</b> Descriptive statistics</a><ul>
<li class="chapter" data-level="3.1.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#frequencies"><i class="fa fa-check"></i><b>3.1.1</b> Frequencies</a></li>
<li class="chapter" data-level="3.1.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#central-tendency"><i class="fa fa-check"></i><b>3.1.2</b> Central tendency</a></li>
<li class="chapter" data-level="3.1.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#dispersion"><i class="fa fa-check"></i><b>3.1.3</b> Dispersion</a></li>
<li class="chapter" data-level="3.1.4" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#associations"><i class="fa fa-check"></i><b>3.1.4</b> Associations</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#bayesian-inferential-statistics"><i class="fa fa-check"></i><b>3.2</b> Bayesian Inferential statistics</a></li>
<li class="chapter" data-level="3.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#bayesian-probability-theory"><i class="fa fa-check"></i><b>3.3</b> Bayesian probability theory</a><ul>
<li class="chapter" data-level="3.3.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#some-set-theory"><i class="fa fa-check"></i><b>3.3.1</b> Some set theory</a></li>
<li class="chapter" data-level="3.3.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#probability"><i class="fa fa-check"></i><b>3.3.2</b> Probability</a></li>
<li class="chapter" data-level="3.3.3" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#certainty-as-probability"><i class="fa fa-check"></i><b>3.3.3</b> Certainty as probability</a></li>
<li class="chapter" data-level="3.3.4" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#bayes-theorem"><i class="fa fa-check"></i><b>3.3.4</b> Bayes theorem</a></li>
</ul></li>
<li class="chapter" data-level="3.4" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#statistical-models"><i class="fa fa-check"></i><b>3.4</b> Statistical models</a><ul>
<li class="chapter" data-level="3.4.1" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#predictions-and-likelihood"><i class="fa fa-check"></i><b>3.4.1</b> Predictions and likelihood</a></li>
<li class="chapter" data-level="3.4.2" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#distributions"><i class="fa fa-check"></i><b>3.4.2</b> Distributions: patterns of randomness</a></li>
</ul></li>
<li class="chapter" data-level="3.5" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#bayesian-estimation"><i class="fa fa-check"></i><b>3.5</b> Bayesian estimation</a></li>
<li class="chapter" data-level="3.6" data-path="bayesian-statistics.html"><a href="bayesian-statistics.html#what-is-wrong-with-classic-statistics-tbc"><i class="fa fa-check"></i><b>3.6</b> What is wrong with classic statistics? [TBC]</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="getting-started-r.html"><a href="getting-started-r.html"><i class="fa fa-check"></i><b>4</b> Getting started with R</a><ul>
<li class="chapter" data-level="4.1" data-path="getting-started-r.html"><a href="getting-started-r.html#setting-up-the-r-environment"><i class="fa fa-check"></i><b>4.1</b> Setting up the R environment</a><ul>
<li class="chapter" data-level="4.1.1" data-path="getting-started-r.html"><a href="getting-started-r.html#installing-cran-packages"><i class="fa fa-check"></i><b>4.1.1</b> Installing CRAN packages</a></li>
<li class="chapter" data-level="4.1.2" data-path="getting-started-r.html"><a href="getting-started-r.html#installing-packages-from-github"><i class="fa fa-check"></i><b>4.1.2</b> Installing packages from Github</a></li>
<li class="chapter" data-level="4.1.3" data-path="getting-started-r.html"><a href="getting-started-r.html#first_program"><i class="fa fa-check"></i><b>4.1.3</b> A first statistical program</a></li>
<li class="chapter" data-level="4.1.4" data-path="getting-started-r.html"><a href="getting-started-r.html#bibliographic-notes"><i class="fa fa-check"></i><b>4.1.4</b> Bibliographic notes</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="getting-started-r.html"><a href="getting-started-r.html#learning-r-a-primer"><i class="fa fa-check"></i><b>4.2</b> Learning R: a primer</a><ul>
<li class="chapter" data-level="4.2.1" data-path="getting-started-r.html"><a href="getting-started-r.html#assigning-and-calling-objects"><i class="fa fa-check"></i><b>4.2.1</b> Assigning and calling Objects</a></li>
<li class="chapter" data-level="4.2.2" data-path="getting-started-r.html"><a href="getting-started-r.html#vectors"><i class="fa fa-check"></i><b>4.2.2</b> Vectors</a></li>
<li class="chapter" data-level="4.2.3" data-path="getting-started-r.html"><a href="getting-started-r.html#basic-object-types"><i class="fa fa-check"></i><b>4.2.3</b> Basic object types</a></li>
<li class="chapter" data-level="4.2.4" data-path="getting-started-r.html"><a href="getting-started-r.html#operators-and-functions"><i class="fa fa-check"></i><b>4.2.4</b> Operators and functions</a></li>
<li class="chapter" data-level="4.2.5" data-path="getting-started-r.html"><a href="getting-started-r.html#storing-data-in-data-frames"><i class="fa fa-check"></i><b>4.2.5</b> Storing data in data frames</a></li>
<li class="chapter" data-level="4.2.6" data-path="getting-started-r.html"><a href="getting-started-r.html#import-export-and-archiving"><i class="fa fa-check"></i><b>4.2.6</b> Import, export and archiving</a></li>
<li class="chapter" data-level="4.2.7" data-path="getting-started-r.html"><a href="getting-started-r.html#case-environments"><i class="fa fa-check"></i><b>4.2.7</b> Case environments</a></li>
<li class="chapter" data-level="4.2.8" data-path="getting-started-r.html"><a href="getting-started-r.html#structuring-data"><i class="fa fa-check"></i><b>4.2.8</b> Structuring data</a></li>
<li class="chapter" data-level="4.2.9" data-path="getting-started-r.html"><a href="getting-started-r.html#data-transformation"><i class="fa fa-check"></i><b>4.2.9</b> Data transformation</a></li>
<li class="chapter" data-level="4.2.10" data-path="getting-started-r.html"><a href="getting-started-r.html#plotting-data"><i class="fa fa-check"></i><b>4.2.10</b> Plotting data</a></li>
<li class="chapter" data-level="4.2.11" data-path="getting-started-r.html"><a href="getting-started-r.html#fitting-regression-models"><i class="fa fa-check"></i><b>4.2.11</b> Fitting regression models</a></li>
<li class="chapter" data-level="4.2.12" data-path="getting-started-r.html"><a href="getting-started-r.html#knitting-statistical-reports"><i class="fa fa-check"></i><b>4.2.12</b> Knitting statistical reports</a></li>
<li class="chapter" data-level="4.2.13" data-path="getting-started-r.html"><a href="getting-started-r.html#exercises-1"><i class="fa fa-check"></i><b>4.2.13</b> Exercises</a></li>
<li class="chapter" data-level="4.2.14" data-path="getting-started-r.html"><a href="getting-started-r.html#bibliographic-notes-1"><i class="fa fa-check"></i><b>4.2.14</b> Bibliographic notes</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="5" data-path="linear-models.html"><a href="linear-models.html"><i class="fa fa-check"></i><b>5</b> Linear models</a><ul>
<li class="chapter" data-level="5.1" data-path="linear-models.html"><a href="linear-models.html#quantification-at-work-grand-mean-models"><i class="fa fa-check"></i><b>5.1</b> Quantification at work: grand mean models</a><ul>
<li class="chapter" data-level="5.1.1" data-path="linear-models.html"><a href="linear-models.html#reading-coefficient-tables"><i class="fa fa-check"></i><b>5.1.1</b> Reading coefficient tables</a></li>
<li class="chapter" data-level="5.1.2" data-path="linear-models.html"><a href="linear-models.html#likelihood-and-random-term"><i class="fa fa-check"></i><b>5.1.2</b> Likelihood and random term</a></li>
<li class="chapter" data-level="5.1.3" data-path="linear-models.html"><a href="linear-models.html#random_walk"><i class="fa fa-check"></i><b>5.1.3</b> Do the random walk: Markov Chain Monte Carlo sampling</a></li>
</ul></li>
<li class="chapter" data-level="5.2" data-path="linear-models.html"><a href="linear-models.html#linear-regression"><i class="fa fa-check"></i><b>5.2</b> Walk the line: linear regression</a><ul>
<li class="chapter" data-level="5.2.1" data-path="linear-models.html"><a href="linear-models.html#transforming-variables"><i class="fa fa-check"></i><b>5.2.1</b> Transforming variables</a></li>
<li class="chapter" data-level="5.2.2" data-path="linear-models.html"><a href="linear-models.html#correlations"><i class="fa fa-check"></i><b>5.2.2</b> Correlations</a></li>
<li class="chapter" data-level="5.2.3" data-path="linear-models.html"><a href="linear-models.html#endlessly-linear"><i class="fa fa-check"></i><b>5.2.3</b> Endlessly linear</a></li>
<li class="chapter" data-level="5.2.4" data-path="linear-models.html"><a href="linear-models.html#posterior-predictions"><i class="fa fa-check"></i><b>5.2.4</b> Posterior predictions</a></li>
<li class="chapter" data-level="5.2.5" data-path="linear-models.html"><a href="linear-models.html#exercises-2"><i class="fa fa-check"></i><b>5.2.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5.3" data-path="linear-models.html"><a href="linear-models.html#CGM"><i class="fa fa-check"></i><b>5.3</b> A versus B: Comparison of groups</a><ul>
<li class="chapter" data-level="5.3.1" data-path="linear-models.html"><a href="linear-models.html#dummy_variables"><i class="fa fa-check"></i><b>5.3.1</b> Not stupid: dummy variables</a></li>
<li class="chapter" data-level="5.3.2" data-path="linear-models.html"><a href="linear-models.html#contrasts"><i class="fa fa-check"></i><b>5.3.2</b> Getting it sharper with contrasts [TBC]</a></li>
<li class="chapter" data-level="5.3.3" data-path="linear-models.html"><a href="linear-models.html#sharper-on-the-fly-derived-quantities-tbd"><i class="fa fa-check"></i><b>5.3.3</b> Sharper on the fly: derived quantities [TBD]</a></li>
<li class="chapter" data-level="5.3.4" data-path="linear-models.html"><a href="linear-models.html#exercises-3"><i class="fa fa-check"></i><b>5.3.4</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5.4" data-path="linear-models.html"><a href="linear-models.html#putting-it-all-together-multi-predictor-models"><i class="fa fa-check"></i><b>5.4</b> Putting it all together: multi predictor models</a><ul>
<li class="chapter" data-level="5.4.1" data-path="linear-models.html"><a href="linear-models.html#on-surface-multiple-regression-models"><i class="fa fa-check"></i><b>5.4.1</b> On surface: multiple regression models</a></li>
<li class="chapter" data-level="5.4.2" data-path="linear-models.html"><a href="linear-models.html#crossover-multifactorial-models-tbc"><i class="fa fa-check"></i><b>5.4.2</b> Crossover: multifactorial models [TBC]</a></li>
<li class="chapter" data-level="5.4.3" data-path="linear-models.html"><a href="linear-models.html#line-by-line"><i class="fa fa-check"></i><b>5.4.3</b> Line-by-line: regression in groups [TBC]</a></li>
<li class="chapter" data-level="5.4.4" data-path="linear-models.html"><a href="linear-models.html#residual-analysis"><i class="fa fa-check"></i><b>5.4.4</b> Residual analysis</a></li>
<li class="chapter" data-level="5.4.5" data-path="linear-models.html"><a href="linear-models.html#how-to-plot-mpm-tbc-move-to-interaction-effects"><i class="fa fa-check"></i><b>5.4.5</b> How to plot MPM? [TBC, move to Interaction effects]</a></li>
<li class="chapter" data-level="5.4.6" data-path="linear-models.html"><a href="linear-models.html#empirical-versus-statistical-control"><i class="fa fa-check"></i><b>5.4.6</b> Empirical versus statistical control</a></li>
<li class="chapter" data-level="5.4.7" data-path="linear-models.html"><a href="linear-models.html#exercises-4"><i class="fa fa-check"></i><b>5.4.7</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5.5" data-path="linear-models.html"><a href="linear-models.html#interaction-effects"><i class="fa fa-check"></i><b>5.5</b> Interaction effects</a><ul>
<li class="chapter" data-level="5.5.1" data-path="linear-models.html"><a href="linear-models.html#differential_design_effects"><i class="fa fa-check"></i><b>5.5.1</b> Users differ: differential design effects</a></li>
<li class="chapter" data-level="5.5.2" data-path="linear-models.html"><a href="linear-models.html#hitting-the-boundaries-of-saturation"><i class="fa fa-check"></i><b>5.5.2</b> Hitting the boundaries of saturation</a></li>
<li class="chapter" data-level="5.5.3" data-path="linear-models.html"><a href="linear-models.html#more-than-the-sum-amplification"><i class="fa fa-check"></i><b>5.5.3</b> More than the sum: amplification</a></li>
<li class="chapter" data-level="5.5.4" data-path="linear-models.html"><a href="linear-models.html#theoretically-interesting-interaction-effects-edit"><i class="fa fa-check"></i><b>5.5.4</b> Theoretically interesting interaction effects [EDIT]</a></li>
<li class="chapter" data-level="5.5.5" data-path="linear-models.html"><a href="linear-models.html#exercises-5"><i class="fa fa-check"></i><b>5.5.5</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="5.6" data-path="linear-models.html"><a href="linear-models.html#polynomial_regression"><i class="fa fa-check"></i><b>5.6</b> Doing the rollercoaster: polynomial regression</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="multilevel-models.html"><a href="multilevel-models.html"><i class="fa fa-check"></i><b>6</b> Multilevel models</a><ul>
<li class="chapter" data-level="6.1" data-path="multilevel-models.html"><a href="multilevel-models.html#average-neverage"><i class="fa fa-check"></i><b>6.1</b> Average? Neverage!</a></li>
<li class="chapter" data-level="6.2" data-path="multilevel-models.html"><a href="multilevel-models.html#the-human-factor-intercept-random-effects"><i class="fa fa-check"></i><b>6.2</b> The Human Factor: Intercept random effects</a></li>
<li class="chapter" data-level="6.3" data-path="multilevel-models.html"><a href="multilevel-models.html#designs-and-other-non-human-populations"><i class="fa fa-check"></i><b>6.3</b> Designs and other non-human populations</a></li>
<li class="chapter" data-level="6.4" data-path="multilevel-models.html"><a href="multilevel-models.html#crossover"><i class="fa fa-check"></i><b>6.4</b> Crossover: Testing Egans assumption</a></li>
<li class="chapter" data-level="6.5" data-path="multilevel-models.html"><a href="multilevel-models.html#measuring-entities-psychometric-applications-tbc"><i class="fa fa-check"></i><b>6.5</b> Measuring entities: psychometric applications [TBC]</a></li>
<li class="chapter" data-level="6.6" data-path="multilevel-models.html"><a href="multilevel-models.html#nested-random-effects"><i class="fa fa-check"></i><b>6.6</b> Nested random effects</a></li>
<li class="chapter" data-level="6.7" data-path="multilevel-models.html"><a href="multilevel-models.html#what-are-random-effects-on-pooling-and-shrinkage"><i class="fa fa-check"></i><b>6.7</b> What are random effects? On pooling and shrinkage</a></li>
<li class="chapter" data-level="6.8" data-path="multilevel-models.html"><a href="multilevel-models.html#slope_RE"><i class="fa fa-check"></i><b>6.8</b> Variance in variation: slope random effects [TBC]</a></li>
<li class="chapter" data-level="6.9" data-path="multilevel-models.html"><a href="multilevel-models.html#re_correlations"><i class="fa fa-check"></i><b>6.9</b> Growing with random effects correlations [TBD]</a></li>
<li class="chapter" data-level="6.10" data-path="multilevel-models.html"><a href="multilevel-models.html#advanced-tricks"><i class="fa fa-check"></i><b>6.10</b> Advanced tricks</a></li>
<li class="chapter" data-level="6.11" data-path="multilevel-models.html"><a href="multilevel-models.html#exercises-7"><i class="fa fa-check"></i><b>6.11</b> Exercises</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="GLM.html"><a href="GLM.html"><i class="fa fa-check"></i><b>7</b> Generalized Linear Models</a><ul>
<li class="chapter" data-level="7.1" data-path="GLM.html"><a href="GLM.html#debunking-the-gaussian-linear-model"><i class="fa fa-check"></i><b>7.1</b> Debunking the Gaussian linear model</a><ul>
<li class="chapter" data-level="7.1.1" data-path="GLM.html"><a href="GLM.html#assuming-linearity"><i class="fa fa-check"></i><b>7.1.1</b> Assuming linearity</a></li>
<li class="chapter" data-level="7.1.2" data-path="GLM.html"><a href="GLM.html#assuming-normal-distribution-of-randomness"><i class="fa fa-check"></i><b>7.1.2</b> Assuming Normal distribution of randomness</a></li>
<li class="chapter" data-level="7.1.3" data-path="GLM.html"><a href="GLM.html#assume-constant-variance"><i class="fa fa-check"></i><b>7.1.3</b> Assuming constant variance of randomness</a></li>
</ul></li>
<li class="chapter" data-level="7.2" data-path="GLM.html"><a href="GLM.html#glm_concepts"><i class="fa fa-check"></i><b>7.2</b> Elements of Generalized Linear Models</a><ul>
<li class="chapter" data-level="7.2.1" data-path="GLM.html"><a href="GLM.html#re-linking-linearity-relinking_linearity-tbc"><i class="fa fa-check"></i><b>7.2.1</b> Re-linking linearity (#relinking_linearity) [TBC]</a></li>
<li class="chapter" data-level="7.2.2" data-path="GLM.html"><a href="GLM.html#choosing-patterns-of-randomness-choosing_randomness"><i class="fa fa-check"></i><b>7.2.2</b> Choosing patterns of randomness (#choosing_randomness)</a></li>
</ul></li>
<li class="chapter" data-level="7.3" data-path="GLM.html"><a href="GLM.html#case-user-testing-infusion-pumps"><i class="fa fa-check"></i><b>7.3</b> Case: user testing infusion pumps</a></li>
<li class="chapter" data-level="7.4" data-path="GLM.html"><a href="GLM.html#count_data"><i class="fa fa-check"></i><b>7.4</b> Count data</a><ul>
<li class="chapter" data-level="7.4.1" data-path="GLM.html"><a href="GLM.html#poisson-regression"><i class="fa fa-check"></i><b>7.4.1</b> Poisson regression</a></li>
<li class="chapter" data-level="7.4.2" data-path="GLM.html"><a href="GLM.html#logistic-aka-binomial-regression-logistic_regression"><i class="fa fa-check"></i><b>7.4.2</b> Logistic (aka Binomial) regression (#logistic_regression)</a></li>
<li class="chapter" data-level="7.4.3" data-path="GLM.html"><a href="GLM.html#modelling-overdispersion"><i class="fa fa-check"></i><b>7.4.3</b> Modelling overdispersion</a></li>
<li class="chapter" data-level="7.4.4" data-path="GLM.html"><a href="GLM.html#exercises-8"><i class="fa fa-check"></i><b>7.4.4</b> Exercises:</a></li>
</ul></li>
<li class="chapter" data-level="7.5" data-path="GLM.html"><a href="GLM.html#measures_of_time"><i class="fa fa-check"></i><b>7.5</b> Measures of time</a><ul>
<li class="chapter" data-level="7.5.1" data-path="GLM.html"><a href="GLM.html#exponential-regression"><i class="fa fa-check"></i><b>7.5.1</b> Exponential regression</a></li>
<li class="chapter" data-level="7.5.2" data-path="GLM.html"><a href="GLM.html#gamma-regression"><i class="fa fa-check"></i><b>7.5.2</b> Gamma regression</a></li>
<li class="chapter" data-level="7.5.3" data-path="GLM.html"><a href="GLM.html#exgaussian-regression"><i class="fa fa-check"></i><b>7.5.3</b> ExGaussian regression</a></li>
<li class="chapter" data-level="7.5.4" data-path="GLM.html"><a href="GLM.html#literature"><i class="fa fa-check"></i><b>7.5.4</b> Literature</a></li>
<li class="chapter" data-level="7.5.5" data-path="GLM.html"><a href="GLM.html#exercises-9"><i class="fa fa-check"></i><b>7.5.5</b> Exercises:</a></li>
</ul></li>
<li class="chapter" data-level="7.6" data-path="GLM.html"><a href="GLM.html#rating-scales"><i class="fa fa-check"></i><b>7.6</b> Rating scales</a><ul>
<li class="chapter" data-level="7.6.1" data-path="GLM.html"><a href="GLM.html#ordered-logistic-regression"><i class="fa fa-check"></i><b>7.6.1</b> Ordered logistic regression</a></li>
<li class="chapter" data-level="7.6.2" data-path="GLM.html"><a href="GLM.html#beta-regression"><i class="fa fa-check"></i><b>7.6.2</b> Beta regression</a></li>
<li class="chapter" data-level="7.6.3" data-path="GLM.html"><a href="GLM.html#distributional-models"><i class="fa fa-check"></i><b>7.6.3</b> Distributional models</a></li>
<li class="chapter" data-level="7.6.4" data-path="GLM.html"><a href="GLM.html#exercises-10"><i class="fa fa-check"></i><b>7.6.4</b> Exercises</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="8" data-path="data-management.html"><a href="data-management.html"><i class="fa fa-check"></i><b>8</b> Data management</a><ul>
<li class="chapter" data-level="8.1" data-path="data-management.html"><a href="data-management.html#modelling-questionnaire-responses"><i class="fa fa-check"></i><b>8.1</b> Modelling questionnaire responses</a></li>
<li class="chapter" data-level="8.2" data-path="data-management.html"><a href="data-management.html#modelling-experimental-responses"><i class="fa fa-check"></i><b>8.2</b> Modelling experimental responses</a></li>
<li class="chapter" data-level="8.3" data-path="data-management.html"><a href="data-management.html#modelling-design-studies-tbd"><i class="fa fa-check"></i><b>8.3</b> Modelling design studies (tbd)</a></li>
<li class="chapter" data-level="8.4" data-path="data-management.html"><a href="data-management.html#modelling-organizational-structures-tbd"><i class="fa fa-check"></i><b>8.4</b> Modelling organizational structures (tbd)</a></li>
<li class="chapter" data-level="8.5" data-path="data-management.html"><a href="data-management.html#modelling-longitudinal-data-tbd"><i class="fa fa-check"></i><b>8.5</b> Modelling longitudinal data (tbd)</a></li>
<li class="chapter" data-level="8.6" data-path="data-management.html"><a href="data-management.html#doing-it-in-r"><i class="fa fa-check"></i><b>8.6</b> Doing it in R</a><ul>
<li class="chapter" data-level="8.6.1" data-path="data-management.html"><a href="data-management.html#creating-and-reading-data"><i class="fa fa-check"></i><b>8.6.1</b> Creating and reading data</a></li>
<li class="chapter" data-level="8.6.2" data-path="data-management.html"><a href="data-management.html#reshaping-data"><i class="fa fa-check"></i><b>8.6.2</b> Reshaping data</a></li>
<li class="chapter" data-level="8.6.3" data-path="data-management.html"><a href="data-management.html#tipps-and-tricks"><i class="fa fa-check"></i><b>8.6.3</b> Tipps and tricks</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">New statistics for the design researcher</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="linear_models" class="section level1">
<h1><span class="header-section-number">5</span> Linear models</h1>
<div id="quantification-at-work-grand-mean-models" class="section level2">
<h2><span class="header-section-number">5.1</span> Quantification at work: grand mean models</h2>
<p>Reconsider Andrew and Jane. They were faced with the problem that potential competitors could challenge the claim “rent a car in 99 seconds” and drag them to court. More precisely, the question was: “will users on average be able …”, which is not about individual users, but the <em>population mean</em>. A statistical model estimating just that we call a <em>grand mean model</em> (GMM). The GMM is the most simple of all models, so in a way, we can think of it as the “grandmother of all models”. Although its is the simplest of all, it is of useful application in design research; here are a few more examples:</p>
<ul>
<li>with medical infusion pump the frequency of decimal input error (giving the tenfold or the tenth of the prescribed dose) must be below a bearable level</li>
<li>the checkout process of an e-commerce website must have a a cancel rate not higher than …</li>
<li>the brake lights of a car must be designed to let the following driver react in a certain time frame</li>
</ul>
<p>The GMM predicts the expected level of performance when the only thing you know is the population someone is from. Prediction here means that the estimated grand mean we take as a best guess for the population average, that is all realizations we have <em>not</em> observed. So, it is a generalization regarding all people we have not invited to the lab, but also potential performance differences by situation, for example the daily shape people are in or their current level of motivation. Just consider the many ways people differ in abilities, experience, strategies, preferences, situations, wishes etc. All these differences may also vary for the same person from day to day and influence performance. All these aspects have not been recorded in the Sec99 study and are therefore not taken into account for prediction. All linear models capture the unpredicted variation in a separate parameter <span class="math inline">\(\sigma\)</span>, the <em>residual standard deviation</em>. <span class="math inline">\(\sigma\)</span> measures the amount of variance that is left after subtracting all explanatory variables. Formally, the likelihood and random formulas of the grand mean model are written with the following likelihood and random term:</p>
<p><span class="math display">\[
\mu = \beta_0\\
y_i \sim \textrm{Norm}(\mu_i, \sigma_\epsilon)
\]</span></p>
<p>The larger <span class="math inline">\(\sigma\)</span> is, the more questionnable it is that the grand mean is truly <em>representative</em> for the population. From the GM we will depart in to directions. First, in the remainder of this chapter, we will add further predictors to the model, for example age of participants or a design condition. These models will still make statements on population averages, although in a more detailed way. In the following chapter on mixed-effects models, individuals will get spot light. Still, what all the advanced models have in common is that they move variance in the outcome variable from the error variance to predictors. An optimist would say: today’s error is tomorrow’s predictor.</p>
<p>So, when estimating the grand mean model, we estimate the intercept <span class="math inline">\(\beta_0\)</span> and the standard deviation of the Gaussian distributed error term <span class="math inline">\(\sigma\epsilon\)</span>. In R, the analysis of the 99 seconds problem unfolds as follows: completion times (ToT) are stored in a data frame, with one observation per row. This data frame is send to the R command <code>stan_glm</code> for estimation, using <code>data = Ver20</code>. As the <code>stan_glm</code> command applies to a huge variety of regression model, the desired model needs further specification. For that purpose, R has its own formula language. The formula of the grand mean model is <code>ToT ~ 1</code>. Left of the <code>~</code> (<em>tilde</em>) operator is the outcome variable. The right hand side specifies the deterministic part. The 1 here has nothing to do with the natural number neighboured by 0 and 2. In R’s formula language it represents the <em>intercept</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Sec99)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> Ver20)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(M_<span class="dv">1</span>)</code></pre></div>
<pre><code>## 
## Model Info:
## 
##  function:     stan_glm
##  family:       gaussian [identity]
##  formula:      ToT ~ 1
##  algorithm:    sampling
##  priors:       see help(&#39;prior_summary&#39;)
##  sample:       4000 (posterior sample size)
##  observations: 100
##  predictors:   1
## 
## Estimates:
##                 mean   sd     2.5%   25%    50%    75%    97.5%
## (Intercept)    106.0    3.1   99.9  103.8  106.0  108.1  112.0 
## sigma           31.5    2.3   27.5   29.9   31.3   33.0   36.5 
## mean_PPD       106.0    4.5   97.2  103.0  106.0  109.0  114.9 
## log-posterior -494.3    1.0 -497.1 -494.7 -494.0 -493.6 -493.3 
## 
## Diagnostics:
##               mcse Rhat n_eff
## (Intercept)   0.1  1.0  2711 
## sigma         0.0  1.0  2709 
## mean_PPD      0.1  1.0  3258 
## log-posterior 0.0  1.0  1382 
## 
## For each parameter, mcse is Monte Carlo standard error, n_eff is a crude measure of effective sample size, and Rhat is the potential scale reduction factor on split chains (at convergence Rhat=1).</code></pre>
<p>The object <code>M_1</code> is the model object created by <code>stan_glm</code>. When you call the summary you complex listings that represent different aspects of the regression. These aspects, and more are saved inside the object in a hierarchy of lists. The central result of the estimation is the <em>posterior distribution (PD)</em>. It is an array of variables over MCMC runs. We extract the posterior distribution from the model object using the <code>posterior</code> command (package: <code>bayr</code>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">posterior</span>(M_<span class="dv">1</span>)
P_<span class="dv">1</span></code></pre></div>
<p>** tbl_post: 4000 samples in 1 chains</p>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="right">parameter</th>
<th align="left">type</th>
<th align="left">fixef</th>
<th align="right">entities</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_1</td>
<td align="right">1</td>
<td align="left">fixef</td>
<td align="left">Intercept</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">parameter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">sigma_resid</td>
</tr>
</tbody>
</table>
<p>The posterior object identifies itself by telling the number of MCMC samples, and the variables contained in the model. In the case here, there is just the intercept (representing the grand mean) and the standard deviation of errors.</p>
<p>Much of the time a researcher doesn’t want to deal with the posterior, directly, but desires a brief summary of location and uncertainty. Coefficient tables are frequently used, just like one one shown below.Coefficient tables report the central tendency of every coefficient, which is an indicator for the magnitude of an effect. Next to that, the spread of the posterior distribution is summarized as 95% credibility intervals and represent the degree of uncertainty: the less certain an estimate is, the wider is the interval. A 95% credibility interval gives a range of possible values where you can be 95% certain that it contains the true value. A coefficient table is produced by the <code>coef</code> command of the bayr library:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coef</span>(P_<span class="dv">1</span>)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">parameter</th>
<th align="left">type</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="left">fixef</td>
<td align="left">Intercept</td>
<td align="right">106.0</td>
<td align="right">99.9</td>
<td align="right">112.0</td>
</tr>
<tr class="even">
<td align="left">sigma_resid</td>
<td align="left">disp</td>
<td align="left">NA</td>
<td align="right">31.3</td>
<td align="right">27.5</td>
<td align="right">36.5</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Sec99)</code></pre></div>
<div id="reading-coefficient-tables" class="section level3">
<h3><span class="header-section-number">5.1.1</span> Reading coefficient tables</h3>
<p>Coefficient tables are the standard way to report regression models. They contain all parameters (or a selection of interest) in rows. For every parameter, the central tendency (center, magnitude, location) is given, and a statement of uncertainty, by convention 95% credibility intervals (CI).</p>
<p>The authors of Bayesian books and the various Bayesian libraries have different opinions on what to report in a coefficient table. Most seem to prefer the posterior mode or the median, only some use the mean.</p>
<p>A disadvantage of the <em>mean</em> is that it may change, under many monotonic transformations. A monotonic transformations is a recoding of a variable <span class="math inline">\(x_1\)</span> into a new variable <span class="math inline">\(x_2\)</span> by a transformation function <span class="math inline">\(\phi\)</span> (<span class="math inline">\(phi\)</span>) such that the order of values stays untouched. Examples of monotonic functions are the logarithm (<span class="math inline">\(x_2 = \log(x_1)\)</span>), the exponential function (<span class="math inline">\(x_2 = \exp(x_1)\)</span>), or simply <span class="math inline">\(x_2 = x_1 + 1\)</span>. A counter example is the quadratic function <span class="math inline">\(x_2 = x_1^2\)</span>. In data analysis monotonous transformations are used a lot. Especially, Generalized Linear Models make use of monotonous link functions to establish linearity <a href="#re-linking-linearity"><strong>??</strong></a>.</p>
<p>The <em>mode</em> of a distribution is its point of highest density. It is invariant under monotonic transformations. It also has a rather intuitive meaning as the most likely value for the true parameter. Next to that, the mode is compatible with classic maximum likelihood estimation. When a Bayesian takes a pass on any prior information, the posterior mode should precisely match the results of a classic regression engine (e.g., <code>glm</code>). The main disadvantage of the mode is that it has to be estimated by one of several heuristic algorithms. These add some computing time and may fail when the posterior distribution is bi-modal. However, when that happens, you probably have a more deeply rooted problem, than just deciding on a suitable summary statistic.</p>
<p>The <em>median</em> of a distribution marks the point where half the values are below and the other half are equal or above. Technically, the median is just the 50% quartile of the distribution. The median is extremely easy and reliable to compute, and it shares the invariance of monotonous transformations. This is easy to conceive: The median is computed by ordering all values in a row and then picking the value that is exactly in the middle. Obviously, this values only changes when the order changes, i.e. a non-monotonous function was applied.</p>
<p>For center estimates I use the posterior median by default, for its simplicity. Researchers who desire downward compatibility with classic regression engines, can easily switch to the mode by using the <span class="math inline">\(estimate\)</span> argument. The following uses the <code>shorth</code> command form the package <code>modeest</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Sec99)</code></pre></div>
<!-- FIXME bayr: dispersion parameter gets no name -->
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">coef</span>(P_<span class="dv">1</span>, <span class="dt">estimate =</span> modeest<span class="op">::</span>shorth)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">parameter</th>
<th align="left">type</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="left">fixef</td>
<td align="left">Intercept</td>
<td align="right">106.0</td>
<td align="right">99.9</td>
<td align="right">112.0</td>
</tr>
<tr class="even">
<td align="left">sigma_resid</td>
<td align="left">disp</td>
<td align="left">NA</td>
<td align="right">31.1</td>
<td align="right">27.5</td>
<td align="right">36.5</td>
</tr>
</tbody>
</table>
<p>Expressing the level of certainty of the posterior distribution makes statistics <em>inferential</em>. When the posterior is widely spread, you will still bet on values close to the center, but keep your bid low. For the spread of a distribution, the standard deviation may come to mind of some readers. The standard deviation has teh disadvantage that a single value does not represent non-symmetric distributions well. A better way is to express certainty as limits, a lower and an upper. The most simple method resembles that of the median by using quantiles. In this book, <em>2.5% and 97.5% certainty quantiles</em> are routinely used to form 95% credibility intervals. Again, another method exists to obtain CIs. Some authors prefer to report the <em>highest posterior interval</em>, which is the narrowest interval that contains 95% of the probability mass. While this is intriguing to some extent, HPDs are not invariant to monotonic transformations.</p>
<p>The <code>coef</code> command by default gives the median and the 2.5% and 97.5% limits. The three parameters have in common that they are quantiles, which are handled by Rs <code>quantile</code> command. To demystify the <code>coef</code>, here is how you can make a basic coefficient table yourself:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_<span class="dv">1</span> <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">group_by</span>(parameter) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">center =</span> <span class="kw">quantile</span>(value, <span class="fl">0.5</span>),
         <span class="dt">lower  =</span> <span class="kw">quantile</span>(value, <span class="fl">0.025</span>),
         <span class="dt">upper  =</span> <span class="kw">quantile</span>(value, <span class="fl">0.975</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">parameter</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">106.0</td>
<td align="right">99.9</td>
<td align="right">112.0</td>
</tr>
<tr class="even">
<td align="left">sigma_resid</td>
<td align="right">31.3</td>
<td align="right">27.5</td>
<td align="right">36.5</td>
</tr>
</tbody>
</table>
<p>Note that we get CIs for the dispersion parameter <span class="math inline">\(\sigma\)</span>, too. Many classic analyses call <span class="math inline">\(\sigma\)</span> are nuisance parameter and ignore it, or they blame high variation between observations for not reaching “significant” certainty for the parameter of interest. Furthermore, classic regression engines don’t yield and measures of certainty on dispersion parameters. I believe that understanding the amount of variation is often crucial for design research and several of the examples that follow try to make the case. This is why we should be glad that Bayesian engines report uncertainty on all parameters involved.</p>
<p>It is common practice to not just drop coefficient tables, but explain and interpret them in written form. My suggestion of how to <em>report regression results</em> is to simply walk through the table row-by-row and for every parameter make two statements: a quantitative statement based on the central tendency, and an uncertainty statement. In the present case that would be:</p>
<ol style="list-style-type: decimal">
<li>The <em>intercept</em> <span class="math inline">\(\beta_0\)</span> is in the region of 106 seconds, which is pretty off the target of 99 seconds.</li>
<li>The certainty is pretty good. At least we can say that the chance of the true mean being 99 seconds or smaller is pretty marginal, as it is not even contained in the 95% CI.</li>
</ol>
<p>And for <span class="math inline">\(\sigma\)</span>:</p>
<ol style="list-style-type: decimal">
<li>The population mean is rather not representative for the observations, as the standard error is almost one third of it.</li>
<li>We can be pretty certain that this is so.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Sec99)</code></pre></div>
</div>
<div id="likelihood-and-random-term" class="section level3">
<h3><span class="header-section-number">5.1.2</span> Likelihood and random term</h3>
<p>In formal language, regression models are usually specified by <em>likelihood functions</em> and one or more <em>random terms</em> (exactly one in linear models). The likelihood represents the common, predictable pattern in the data. Formally, the likelihood establishes a link between <em>predicted values</em> <span class="math inline">\(mu_i\)</span> and predictors. It is common to call predictors with the Greek letter <span class="math inline">\(\beta\)</span> (beta). If there are more than one predictors, these are marked with subscripts, starting at zero. The “best guess” is called the <em>expected value</em> and is denoted with <span class="math inline">\(\mu\)</span> (mu_i). If you just know that the average ToT is 106 seconds and you are asked to guess the performance of the next user arriving in the lab, the reasonable guess is just that, 106 seconds.</p>
<p><span class="math display">\[\mu_i = \beta_0\]</span></p>
<p>Of course, we would never expect this person to use 106 second, exactly. All observed and imagined observations are more or less clumped around the expected value. The <em>random term</em> specifies our assumptions on the pattern of randomness. It is given as a distributions (note the plural), denoted by the <span class="math inline">\(\sim\)</span> (tilde) operator, which reads as: “is distributed”. In the case of linear models, the assumed distribution is always the Normal or <em>Gaussian distribution</em>. Gaussian distributions have a characteristic bell curve and depend on two parameters: the mean <span class="math inline">\(\mu\)</span> as the central measure and the standard deviation <span class="math inline">\(\sigma\)</span> giving the spread.</p>
<p><span class="math display">\[y_i \sim N(\mu_i, \sigma_{\epsilon})\]</span></p>
<p>The random term specifies how all unknown sources of variation take effect on the measures, and these are manifold. Randomness can arise due to all kinds of individual differences, situational conditions and, last but not least, measurement errors. The Gaussian distribution often is a good approximation for randomness and linear models are routinely used in research. In several classic statistics books, the following formula is used to describe the GMM (and likewise more complex linear models):</p>
<p><span class="math display">\[
y_i = \mu_i + \epsilon_i\\
\mu_i = \beta_0\\
\epsilon_i \sim \textrm{Norm}(0, \sigma_\epsilon)
\]</span></p>
<p>First, it is to say, that the two ways of formula are mathematically equivalent. The primary difference to our formula is that the <em>residuals <span class="math inline">\(\epsilon_i\)</span></em>, are given separately. The pattern of residuals is then specified as a single Normal distribution. Residual distributions are a highly useful concept in modelling as they can be used to check a given model. When residuals are such a highly useful concept, the classic formula is more intuitive. The reason for separating the model into likelihood and random term is that it works in more cases. When turning to Generalized Linear Models (GLM) in chapter <a href="#generalized-linear-models"><strong>??</strong></a>, we will use other patterns of randomness, that are no longer additive, like in <span class="math inline">\(\mu_i + \epsilon_i\)</span>. As I consider the use of GLMs an element of professional statistical practice, I use the general formula right from the start.</p>
</div>
<div id="random_walk" class="section level3">
<h3><span class="header-section-number">5.1.3</span> Do the random walk: Markov Chain Monte Carlo sampling</h3>
<p>So far, we have seen how linear models are specified and how,parameters are interpreted from standard coefficient table. While it is convenient to have a standard procedure it turns out very useful to understand how these estimates came to life. In Bayesian estimation, the <em>posterior distribution (PD)</em> is the central point of departure for any such statements. The PD assigns a degree of certainty for every possible combination of parameter values. In the current case, you can ask the PD, where and how certain the population mean and the residual standard error are, but you can also ask: How certain are we that the population mean is smaller than 99 seconds and <span class="math inline">\(\sigma\)</span> is smaller than 10?</p>
<p>In a perfect world, we would know the analytic formula of the posterior and derive statements from it. In most non-trivial cases, though, there is no such formula one can work with. Instead, what the regression engine does is to approximate the PD by a random-walk algorithm called Markov-Chain Monte Carlo sampling (MCMC).</p>
<p>In fact, the <code>stan_glm</code> command returns a large object that stores, among others, the full random walk. This random walk represent the posterior distribution almost directly. The following code extracts this the posterior distribution from the regression object prints it. When calling the new object (class: tbl_post) directly, it provides a compact summary of all variables in the model, here this is the intercept and the residual standard error.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Sec99)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_<span class="dv">1</span> &lt;-<span class="st">  </span><span class="kw">posterior</span>(M_<span class="dv">1</span>)
P_<span class="dv">1</span></code></pre></div>
<p>** tbl_post: 4000 samples in 1 chains</p>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="right">parameter</th>
<th align="left">type</th>
<th align="left">fixef</th>
<th align="right">entities</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_1</td>
<td align="right">1</td>
<td align="left">fixef</td>
<td align="left">Intercept</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">parameter</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">sigma_resid</td>
</tr>
</tbody>
</table>
<p>The 99 second GMM has two parameters and therefore the posterior distribution has three dimensions: the parameter dimensions <span class="math inline">\(\beta_0\)</span>, <span class="math inline">\(\sigma\)</span> and the probability density. Three dimensional plots are difficult to put on a surface, but for somewhat regular patterns, a density plot with contour lines do a sufficient job:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(chain, iter, parameter, value) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(parameter, value) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> Intercept, <span class="dt">y =</span> sigma_resid, <span class="dt">fill =</span> ..level..)) <span class="op">+</span>
<span class="st">  </span><span class="kw">stat_density_2d</span>(<span class="dt">geom =</span> <span class="st">&quot;polygon&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlim</span>(<span class="dv">95</span>, <span class="dv">115</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylim</span>(<span class="dv">25</span>, <span class="dv">40</span>)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p>Let’s see how this PD “landscape” actually emerged from the random walk. In the current case, the <em>parameter space</em> is two-dimensional, as we have <span class="math inline">\(\mu\)</span> and <span class="math inline">\(\sigma\)</span>. The MCMC procedure starts at a deliberate point in parameter space. At every iteration, the MCMC algorithm attempts a probabilistic jump to another location in parameter space and stores the coordinates. This jump is called probabilistic, because it is either carried out, or not, and that depends on a bet. If the new target is in a highly likely region, it is carried out with a higher chance. This sounds circular, but it works and, of course, it has been proven mathematically that it works.</p>
<p>The regression object stores the MCMC results as a long series of positions in parameter space. For any range of interest, it is the relative frequency of visits that represents its certainty. The first 50 hundred steps of the MCMC random walk are shown in @ref(99_seconds_random_walk)`. Apparently, the random walk is not fully random, as the point cloud is more dense in the center area. This is where the more probable parameter values lie. One can clearly see how the MCMC algorithm jumps to more likely areas more frequently. These areas become more dense and, finally, the cloud of visits will approach the contour density plot above.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">G_random_walk &lt;-
<span class="st">  </span>P_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(iter <span class="op">&lt;=</span><span class="st"> </span><span class="dv">50</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(iter, parameter, value) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(parameter, value) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> Intercept, <span class="dt">y =</span> sigma_resid, <span class="dt">label =</span> iter)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_text</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_path</span>(<span class="dt">alpha =</span> .<span class="dv">3</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">ylab</span>(<span class="st">&quot;residual sd&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlab</span>(<span class="st">&quot;intercept mu&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlim</span>(<span class="dv">95</span>, <span class="dv">115</span>) <span class="op">+</span><span class="st"> </span><span class="kw">ylim</span>(<span class="dv">25</span>, <span class="dv">40</span>)

G_random_walk</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/99_seconds_random_walk-1.png" width="672" /></p>
<p>The more complex regression models grow, the more dimensions the PD gets. The linear regression model in the next chapter has a three parameter dimensions, which is difficult to visualize. Multi-level models have hundreds of parameters, which is impossible to intellectually grasp at once. Therefore, it is common to use the <em>marginal posterior distributions</em> (MPD), which give the density of one coefficient at time. My preferred geometry for plotting MPDs is the violin plot, which packs a bunch of densities and therefore can be used for models of higher dimension. Still, for simple models histograms do the job:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> value)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_histogram</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(. <span class="op">~</span><span class="st"> </span>parameter, <span class="dt">scales =</span> <span class="st">&quot;free&quot;</span>)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/99_seconds_post-1.png" width="672" /></p>
<p>In our example, in @ref(99_seconds_post) we can spot that the most likely value for average time-on-task is <span class="math inline">\(106.1\)</span>. Both distributions have a certain spread. With a wider PD, far-off values have been visited by the MCMC chain more frequently. The probability mass is more evenly distributed and there is less certainty for the parameter to fall in the central region. In the current case, a risk averse decision maker would maybe take the credibility interval as “reasonably certain”.</p>
<p>Andrew and Jane expect some scepticism from the marketing people, and some lack in statistical skills, too. What would be the most comprehensible single number to report? As critical decisions are involved, it seems plausible to report the risk to err: how certain are they that the true value is more than 99 seconds. We inspect the histograms. The MPD of the intercept indicates that the average time-on-task is rather unlikely in the range of 99 seconds or better. But what is the precise probability to err for the 99 seconds statement? The above summary with <code>fixef()</code> does not answer the question, accurately. The CI gives lower and upper limits for a range of 95% certainty in total. What is needed is the certainty of <span class="math inline">\(\mu \geq 99\)</span>. Specific questions deserve precise answers. And once we have understood the MCMC chain as a frequency distribution, the answer is easy: we simply count how many visited values are larger than 99. In R, the <code>quantile</code> function handles the job:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_certainty &lt;-
<span class="st">  </span>P_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(parameter <span class="op">==</span><span class="st"> &quot;Intercept&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">summarize</span>(<span class="dt">certainty_99s =</span> <span class="kw">mean</span>(value <span class="op">&gt;=</span><span class="st"> </span><span class="dv">99</span>),
            <span class="dt">certainty_111s =</span> <span class="kw">mean</span>(value <span class="op">&gt;=</span><span class="st"> </span><span class="dv">111</span>))

<span class="kw">kable</span>(T_certainty)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">certainty_99s</th>
<th align="right">certainty_111s</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0.986</td>
<td align="right">0.054</td>
</tr>
</tbody>
</table>
<p>It turns out that the certainty for average time-on-task above the 99 is an overwhelming 0.986. The alternative claim, that average completion time is better than 111 seconds, has a rather moderate risk to err (0.054).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Sec99)</code></pre></div>
</div>
</div>
<div id="linear-regression" class="section level2">
<h2><span class="header-section-number">5.2</span> Walk the line: linear regression</h2>
<p>In the previous section we have introduced the mother of all regression models: the grand mean model. It assigns rather coarse predictions, without any real predictors. Routinely, design researchers desire to predict performance based on <em>metric variables</em>, such as:</p>
<ul>
<li>previous experience</li>
<li>age</li>
<li>font size</li>
<li>intelligence level and other innate abilities</li>
<li>level of self efficiacy, neuroticism or other traits</li>
<li>number of social media contacts</li>
</ul>
<p>To carry out such a research question, the variable of interest needs to be measured, next to the outcome variable. And, the variable must vary. You cannot examine the effects of age of font size on reading performance, when all participants are psychology students or you test only one size. Then, for specifying the model, the researcher has to come up with an expectation of how the two are related. Theoretically, that can be any mathematical function, but practically, a <em>linear function</em> is often presumed for its simplicity. The following plot shows a variety of linear relations between two variables <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">mascutils<span class="op">::</span><span class="kw">expand_grid</span>(<span class="dt">intercept =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>),
                       <span class="dt">slope =</span> <span class="kw">c</span>(<span class="op">-</span>.<span class="dv">5</span>, <span class="dv">0</span>, <span class="fl">1.5</span>),
                       <span class="dt">x =</span> <span class="op">-</span><span class="dv">3</span><span class="op">:</span><span class="dv">3</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">arrange</span>(x) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">y =</span> intercept <span class="op">+</span><span class="st"> </span>x <span class="op">*</span><span class="st"> </span>slope,
         <span class="dt">slope =</span> <span class="kw">as.factor</span>(slope)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y, <span class="dt">color =</span> slope)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(<span class="op">~</span>intercept)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
<p>A linear function is a straight line, which is specified by two parameters: <em>intercept</em> <span class="math inline">\(\beta_0\)</span> and <em>slope</em> <span class="math inline">\(\beta_1\)</span>: <span class="math display">\[f(x_1) = \beta_0 + \beta_1x_{1i}\]</span> The intercept is <em>“the point where a function graph crosses the x-axis”</em>, or more formally:</p>
<p><span class="math display">\[f(x_1 = 0) = \beta_0\]</span></p>
<p>The second parameter, <span class="math inline">\(\beta_1\)</span> is called the <em>slope</em>. The slope determines the steepness of the line. When the slope is <span class="math inline">\(1\)</span>, the line will raise by this amount when one moves one step to the right.</p>
<p><span class="math display">\[f(x_1 + 1) = \beta_0 + \beta_1x_{1i} + \beta_1\]</span></p>
<p>There is also the possibility that the slope is zero. In such a case, the predictor has no effect and can be left out. Setting <span class="math inline">\(\beta_1 = 0\)</span> produces a horizontal line, with <span class="math inline">\(y\)</span> being constant over the whole range. This shows that The LRM can be conceived a generalization of the GM model: <span class="math inline">\(\mu_i = \beta_0\)</span>.</p>
<p>Linear regression gives us the opportunity to discover how ToT can be predicted by age (<span class="math inline">\(x_1\)</span>) in the BrowsingAB case. IN this synthetic experiment, two designs A and B are compared, but this is what we ignore for now. Instead, we ask: are older people slower on the internet? or: is there a linear relationship between age and ToT? The likelihood and random terms of the LRM are:</p>
<p><span class="math display">\[\mu_i = \beta_0 + \beta_1x_{1i}\]</span> <span class="math display">\[Y_i = N(\mu_i, \sigma)\]</span></p>
<p>This literally means: with every year of age, ToT increases by the <span class="math inline">\(\beta_1\)</span> seconds. Before we run a linear regression with <code>stan_glm</code>, we visually explore the association between age and ToT using a scatter plot. The blue line in the graph is a so called a <em>smoother</em>, more specifically a LOESS. A smoother is an estimated line, just as linear function. But, it is way more flexible. Where the linear function is a lever fixed at a pivotal point, LOESS is a pipe cleaner. LOESS shows a more detailed picture of the relation between age and ToT. There is a rise between 20 and 40, followed by a stable plateau, and another rise starting at 60. Actually, that does not look like a straight line, but at least there is steady upwards trend.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">G_eda_<span class="dv">1</span> &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> age, <span class="dt">y =</span> ToT)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>()<span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> F, <span class="dt">fullrange =</span> F)

G_eda_<span class="dv">1</span></code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/BAB_G_eda_1-1.png" width="672" /></p>
<p>In fact, the BrowsingAB data contains what one could call a psychological model. The effect of age is partly due to farsightedness of participants (making them slower at reading), which more or less suddenly kicks in at a certain range of age. Still, we currently make do with a rough linear approximation. To estimate the model, we use the <code>stan_glm</code> command in much the same way as before, but add the predictor age. The command will internally check the data type of your variable, which is metric, here. Therefore, it is treated as a metric predictor or <em>covariate</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_age &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>age, 
           <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_age &lt;-<span class="st"> </span><span class="kw">fixef</span>(M_age)
T_age</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">164.090</td>
<td align="right">143.152</td>
<td align="right">185.18</td>
</tr>
<tr class="even">
<td align="left">age</td>
<td align="right">0.642</td>
<td align="right">0.234</td>
<td align="right">1.04</td>
</tr>
</tbody>
</table>
<p>Is age associated with ToT? The coefficient table tells us that with every year of age, users get <span class="math inline">\(0.64\)</span> seconds slower, which is considerable. It also tells us that the predicted performance at age = 0 is <span class="math inline">\(164.09\)</span>.</p>
<div id="transforming-variables" class="section level3">
<h3><span class="header-section-number">5.2.1</span> Transforming variables</h3>
<p>The intercept parameter refers to the predicted ToT of a new born. That is a bizarre prediction and we would never seriously put that forward in a stakeholder presentation, or in the conclusion of a scientific paper, would we not? Besides that, the intercept estimate is rather uncertain, with a wide 95% interval, <span class="math inline">\(164.09 [143.15, 185.18]_{CI95}\)</span>.</p>
<p>Both, implausibility and high certainty are rooted in the same problem: the model puts a parameter, where there is no data. The broad region of the intercept is as empty as the Khali desert, because observations are impossible or have not been recorded. Fortunately, there is a pragmatic solution to the problem: <em>shifting the predictor</em>. “Shifting” literally means that the age predictor is moved to the right or the left, such that the zero point is in a region populated with observations. In the case, here, two options seem to make sense: either, the intercept is in the region of youngest participants, or it is the sample average, which is then called <em>centering</em>. To shift a variable, just subtract the amount of units (years) where you want the intercept to be. Figure XY shows a shift of -20 and a centering shift on the original variable age</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">age_shft =</span> age <span class="op">-</span><span class="st"> </span><span class="dv">20</span>,
         <span class="dt">age_cntr =</span> age <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(age))

BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>tidyr<span class="op">::</span><span class="kw">gather</span>(<span class="st">&quot;predictor&quot;</span>, <span class="st">&quot;age&quot;</span>, <span class="kw">starts_with</span>(<span class="st">&quot;age&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> age, <span class="dt">y =</span> ToT)) <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(predictor<span class="op">~</span>.) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> F, <span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">fullrange =</span> T)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>By shifting the age variable, the whole data cloud is moved to the left. To see what happens on the inferential level, we repeat the LRM estimation with the two shifted variables:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_age_shft &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>age_shft, <span class="dt">data =</span> BAB1)

M_age_cntr &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>age_cntr, <span class="dt">data =</span> BAB1)</code></pre></div>
<p>We combine the posterior distributions into one multi-model posterior and read the <em>multi-model coefficient table</em>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_age &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">bind_rows</span>(<span class="kw">posterior</span>(M_age), 
            <span class="kw">posterior</span>(M_age_shft), 
            <span class="kw">posterior</span>(M_age_cntr))


T_age &lt;-<span class="st"> </span><span class="kw">fixef</span>(P_age)
T_age</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_age</td>
<td align="left">Intercept</td>
<td align="right">164.090</td>
<td align="right">143.152</td>
<td align="right">185.18</td>
</tr>
<tr class="even">
<td align="left">M_age</td>
<td align="left">age</td>
<td align="right">0.642</td>
<td align="right">0.234</td>
<td align="right">1.04</td>
</tr>
<tr class="odd">
<td align="left">M_age_cntr</td>
<td align="left">Intercept</td>
<td align="right">195.888</td>
<td align="right">189.843</td>
<td align="right">202.09</td>
</tr>
<tr class="even">
<td align="left">M_age_cntr</td>
<td align="left">age_cntr</td>
<td align="right">0.641</td>
<td align="right">0.265</td>
<td align="right">1.05</td>
</tr>
<tr class="odd">
<td align="left">M_age_shft</td>
<td align="left">Intercept</td>
<td align="right">176.688</td>
<td align="right">163.262</td>
<td align="right">190.25</td>
</tr>
<tr class="even">
<td align="left">M_age_shft</td>
<td align="left">age_shft</td>
<td align="right">0.645</td>
<td align="right">0.256</td>
<td align="right">1.04</td>
</tr>
</tbody>
</table>
<p>When comparing the regression results The shifted intercepts have moved to higher values, as expected. Surprisingly, the simple shift is not exactly 20 years. This is due to the high uncertainty of the first model, as well as the relation not being exactly linear (see Figure XY). The shifted age predictor has a slightly better uncertainty, but not by much. This is, because the region around the lowest age is scarcely populated with data for the very reason. Centering on the other hand results in a highly certain estimate, no surprisingly, as the region is densily populated. At the same time, the slope parameter practically does not change, neither in magnitude nor in certainty.</p>
<p>An even stronger standardization is <em>z-transformation</em>, where the predictor is centered at zero and all values are divided by the standard deviation, which results in a change of spread:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">age_z =</span> (age <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(age))<span class="op">/</span><span class="kw">sd</span>(age),
         <span class="dt">age_cntr =</span> age <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(age))

BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span>tidyr<span class="op">::</span><span class="kw">gather</span>(<span class="st">&quot;predictor&quot;</span>, <span class="st">&quot;age&quot;</span>, age, age_z) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> age, <span class="dt">y =</span> ToT)) <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(predictor<span class="op">~</span>.) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">se =</span> F, <span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">fullrange =</span> T)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<p>A z-transformed variable is centered on zero and has a standard deviation of one. As can be seen, z-transformation has a considerable effect on the slope. Pulling the data cloud together pulls up the slope. Again, we run an LRM and compare against the original model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_age_z &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>age_z, <span class="dt">data =</span> BAB1)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_age &lt;-<span class="st">  </span><span class="kw">bind_rows</span>(P_age, <span class="kw">posterior</span>(M_age_z))
T_age &lt;-<span class="st"> </span><span class="kw">fixef</span>(P_age)
T_age</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_age</td>
<td align="left">Intercept</td>
<td align="right">164.090</td>
<td align="right">143.152</td>
<td align="right">185.18</td>
</tr>
<tr class="even">
<td align="left">M_age</td>
<td align="left">age</td>
<td align="right">0.642</td>
<td align="right">0.234</td>
<td align="right">1.04</td>
</tr>
<tr class="odd">
<td align="left">M_age_cntr</td>
<td align="left">Intercept</td>
<td align="right">195.888</td>
<td align="right">189.843</td>
<td align="right">202.09</td>
</tr>
<tr class="even">
<td align="left">M_age_cntr</td>
<td align="left">age_cntr</td>
<td align="right">0.641</td>
<td align="right">0.265</td>
<td align="right">1.05</td>
</tr>
<tr class="odd">
<td align="left">M_age_shft</td>
<td align="left">Intercept</td>
<td align="right">176.688</td>
<td align="right">163.262</td>
<td align="right">190.25</td>
</tr>
<tr class="even">
<td align="left">M_age_shft</td>
<td align="left">age_shft</td>
<td align="right">0.645</td>
<td align="right">0.256</td>
<td align="right">1.04</td>
</tr>
<tr class="odd">
<td align="left">M_age_z</td>
<td align="left">Intercept</td>
<td align="right">195.873</td>
<td align="right">189.852</td>
<td align="right">202.37</td>
</tr>
<tr class="even">
<td align="left">M_age_z</td>
<td align="left">age_z</td>
<td align="right">10.118</td>
<td align="right">3.720</td>
<td align="right">16.24</td>
</tr>
</tbody>
</table>
<p>As expected, the intercept matches that of the centered variable. The small deviations are due to the [random walk] (#random_walk) and disappear when running longer MCMC chains. The slope parameter has inflated dramatically. That, of course, is not a magical trick to obtain more impressive numbers, it is simply the effect of dividing the original variable by its standard deviation. A step of one on <code>age</code> is exactly one year, whereas in <code>age_z</code> it is <em>one standard deviation</em>. Z-transformation adjusts a variable by its observed dispersion, measured as standard deviations. In the case of age, this is not very desirable.</p>
<p>Years of age is a natural and commonly understood unit and my advice would be to use centering, leaving the unit size untouched. When dealing with variables that are pseudo-metric, rating scales in particular, z-transformation makes sense. Imagine you were stranded on a tropical island. While putting together a shelter, you realize of useful a meter stick is. The <em>ur meter</em> is thousands of kilometers away. Obviously, you can bootstrap yourself by picking up a reasoable straight stick and mark 10 (or eight) equally spaced sections. With z-transformation you are picking your unit of measurment on what you find, too. Still, “one standard deviation” is hard to swallow for anyone untrained. If we can assume the measurement to be normally distributed, which is frequently a good approximation for rating scale data, we can derive relative statements. As it happens, the central two standard deviations cover around two thirds of the full area, leaving one sixth to each tail. That allows to make quantile statements, such as: Within central two thirds regarding age, ToT moves up by <span class="math inline">\(2 \beta_1 = 10.12\)</span> seconds, if age is truly Normal, of course.</p>
<p>A general useful application of z-scores is to bootstrap a common unit for a diverse set of measures. Think of a battery of Likert scales, that all choose their own ranges. With z-scores we can compare the relative impact of several predictors in a population. In fact, that even makes sense for the age model. As it happens, the random variation parameter <span class="math inline">\(\sigma\)</span> is given in standard deviation units, too. We can conclude that the age effect causes just a moderate fraction of all the variation observed. More research is needed.</p>
</div>
<div id="correlations" class="section level3">
<h3><span class="header-section-number">5.2.2</span> Correlations</h3>
<p>LRM render the relationship between two metric variables. A commonly known statistic that seems to do the same is Pearson’s correlation coefficient <span class="math inline">\(r\)</span> (@(#associations)). In the following, we will see that a tight connection between correlation and linear coefficients exists, albeit both having their own advantages. For a demonstration, we reproduce the steps on a smimulated data set where X and Y are linearly linked:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_cor &lt;-
<span class="st">  </span><span class="kw">data_frame</span>(<span class="dt">x =</span> <span class="kw">runif</span>(<span class="dv">100</span>, <span class="dv">0</span>, <span class="dv">50</span>),
             <span class="dt">y =</span> <span class="kw">rnorm</span>(<span class="dv">100</span>, x <span class="op">*</span>.<span class="dv">2</span>, <span class="dv">3</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_cor <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> x, <span class="dt">y =</span> y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">se =</span> F)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-24-1.png" width="672" /></p>
<p>Recall, that <span class="math inline">\(r\)</span> is covariance standardized for dispersion and that a covariance is the mean squared deviance from the population mean. This is how the correlation coefficient is decontaminated from the idiosyncracies of the involved measures, their location and dispersion. In contrast, slope parameter in an LRM is a measure of association, too. It is agnostic of the overall location of measures, because this is captured by the intercept. However, dispersion remains intact. That makes that slope and intercept together retain information about location, dispersion and association of data and we can ultimately make predictions. Still, there is a tight re.lationship between Pearson <span class="math inline">\(r\)</span> and a slope coefficient <span class="math inline">\(\beta_1\)</span>, namely:</p>
<p><span class="math display">\[
r = \beta_1 \frac{sd_X}{sd_Y}
\]</span></p>
<p>For the sole purpose of demonstration, we here resort to the built-in non-Bayesian command <code>lm</code> for doing the regression.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_cor &lt;-<span class="st"> </span><span class="kw">lm</span>(y <span class="op">~</span><span class="st"> </span>x, D_cor)
beta_<span class="dv">1</span> &lt;-<span class="st"> </span>stats<span class="op">::</span><span class="kw">coef</span>(M_cor)[<span class="dv">2</span>]

r &lt;-<span class="st"> </span>beta_<span class="dv">1</span> <span class="op">*</span><span class="st"> </span><span class="kw">sd</span>(D_cor<span class="op">$</span>x) <span class="op">/</span><span class="st"> </span><span class="kw">sd</span>(D_cor<span class="op">$</span>y)
r</code></pre></div>
<pre><code>##     x 
## 0.723</code></pre>
<p>The clue with Pearson <span class="math inline">\(r\)</span> is that it normalized the slope coefficient by the variation found in the sample. This reminds of z-transformation as was introduced in <a href="linear-models.html#transforming-variables">5.2.1</a>. In fact, when both, predictor and outcome, are z-transformed before estimation, the coefficient equals Pearson’s <span class="math inline">\(r\)</span>, right away:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_z &lt;-
<span class="st">  </span>D_cor <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">x_z =</span> (x <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(x))<span class="op">/</span><span class="kw">sd</span>(x),
         <span class="dt">y_z =</span> (y <span class="op">-</span><span class="st"> </span><span class="kw">mean</span>(y))<span class="op">/</span><span class="kw">sd</span>(y)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">lm</span>(y_z <span class="op">~</span><span class="st"> </span>x_z, .)

stats<span class="op">::</span><span class="kw">coef</span>(M_z)[<span class="dv">2</span>]</code></pre></div>
<pre><code>##   x_z 
## 0.723</code></pre>
<!-- #29

Pearson's $r$ spawns from a different school of thinking than Bayesian parameter estimation: analysis of variance (ANOVA). Roughly, this family of methods draws on the idea of dividing the *total variance* of the outcome variable into two components: *explained variance* and *residual variance*. The very formula of the variance parameter reveals its connection to covariance (it is even allowed to say, that variance is the covariance of a variable with itself):

$$
\textrm{Var}_{X} = \frac{1}{n} \sum_{i=1}^n (x_i - E(X))^2
$$
In ANOVA models, when explained variance is large, as compared to residual variance, the F-statistic goes up and stars twinkle behind the p-value. While I am far from promoting any legacy approaches, here, a scale-less measure of association strength bears some intuition in situations, where at least one of the involved variables has no well-defined scale. That is in particular the case, when measuring with rating scales. Measurement theory tells that we may actually transform rating scales fully to our liking, if the order is preserved (ordinal scales). That is a pretty weak criterion and, strictly speaking, forbids the application of linear models (and ANOVA) altogether, where at least sums must be well defined (interval scales).

Not by coincidence, a measure of explained variance, the *coefficient of determination r^2* can be derived as from Pearson's $r$, by simply squaring it. $r^2$ is in the range $[0;1]$ and represents the proportion of variability that is explained by the predictor:


```r
str_c("X explains r^2 = ",round(r^2,2) * 100, " percent of the variance of Y")
```

```
## [1] "X explains r^2 = 52 percent of the variance of Y"
```

To sum it up, Perason $r$ and $r^2$ are useful statistic to express the strength of an association, when the scale of measurement does not matter or when obe desires to compare across scales. Furthermore, correlations can be part of advanced multilevel models which we will treat in 
-->
<p>In regression modelling the use of coefficients prevales because they allow for predictions. However, correlation coefficients play a major role in two situations: in exploratory data analysis and in multilevel models. With the latter we will deal in @(re_correlations). For exploratory data analysis it is recommended to inspect pairwise correlations for the following reasons:</p>
<ol style="list-style-type: decimal">
<li>Correlations between predictors and responses are a quick and dirty assessment of the expected associations</li>
<li>Correlations between multiple response modalities (e.g., ToT and number of errors) indicate to what extent these responses can be considered exchangeable.</li>
<li>Correlations between predictors should be checked upfront to avoid problems arising from so-called colinearity.</li>
</ol>
<!-- #30 
Linear models link multiple predictors to an outcome variable. In the MMN case we observed that, by adding another predictor to a model, the strength of the original predictor only changes marginally. That is *not* the general rule as we will see now!

Why is it better to have three legs under a table than four? Because three legs are always stable, no beer coasters needed. Recall basic geometry: the straight connection between two points is called a line (like in regression line). Three points make a triangle. An astonishing property of triangles is that in a three-dimension space they are always flat. Never is there bending needed to connect three points.
-->
<!--
Elaborations on Euclidean space, how double linear regression creates flat surfaces and how colinearity reduces this to a line that is unstable.-->
</div>
<div id="endlessly-linear" class="section level3">
<h3><span class="header-section-number">5.2.3</span> Endlessly linear</h3>
<p>On a deeper level the bizarre age = 0 prediction is an example of a principle, that will re-occur several times throughout this book.</p>
<p><strong>In an endless universe, everything is finite.</strong></p>
<p>A well understood fact about LRM is that they allow us to fit a straight line to data. A lesser regarded consequence from the mathematical underpinnings of such models is that this line extends infinitely in both directions. To fulfill this assumption, the outcome variable needs to have an infinite range, too, <span class="math inline">\(y_i \in [-infty; \infty]\)</span> (unless the slope is zero). Every scientifically trained person and many lay people know, that even elementary magnitude in physics are finite: all speeds are limited to <span class="math inline">\(\approx 300.000 km/s\)</span>, the speed of light and temperature has a lower limit of -276°C (or 0K). If there can neither be endless acceleration nor cold, it would be daring to assume any psychological effect to be infinite in both directions.</p>
<p>The endlessly linear assumption (ELA) is a central piece of all LRM. From a formal perspective, the ELA is always violated in a universe like ours. So, should we never ever use a linear model and move on to non-linear models right away? Pragmatically, the LRM often is a reasonably effective approximation. From figure [G_eda_1] we have seen that the increase is not strictly linear, but follows a more complex curved pattern. This pattern might be of interest to someone studying the psychological causes of the decline in performance. For the applied design researcher it probably suffices to summarize the monotonous relationship by the slope coefficient. In <a href="linear-models.html#line-by-line">5.4.3</a> we will estimate the age effects for designs A and B, separately, which lets us compare fairness towards older people.</p>
<p>As has been said theorists may desire more detailed picture and see disruptions of linearity as indicators for interesting psychological processes. An uncanny example of theoretical work will be given in polynomial regression. For the rest of us, linear regression is a pragmatic choice, as long as:</p>
<ol style="list-style-type: decimal">
<li>the pattern is monotonically increasing</li>
<li>any predictions stay in the observed range and avoid the boundary regions, or beyond.</li>
</ol>
</div>
<div id="posterior-predictions" class="section level3">
<h3><span class="header-section-number">5.2.4</span> Posterior predictions</h3>
<p>In Bayesian regression models, <em>posterior predictions</em> are a simple, yet powerful concept to compare the fitted model with the original data. As [McElreath] points out, one should rather call them <em>retrodictions</em>, because they regard the real data one has, not the future. In yet another perspective they are <em>idealized responses</em> and as such address both, present and future. Posterior predictions are routinely compared to <em>observed values</em> <span class="math inline">\(y_i\)</span> which are known beforehand, but still contain the randomness component. Fitting a linear model basically means separating the idealized effect from the randomness. When the model is somewhat well-specified, this succeeds but comes at the costs of uncertainty: the <em>predicted value is a random variable, too</em>.</p>
<p>In the BrowsingAB case, we have repeatedly recorded age of participant. LRM found the repeating pattern, that with every unit of age, ToT increased by 0.645 seconds. This pattern is what the model predicts, now and forever. If we ask: what is predicted for a person of age 45? We get the predicted value <span class="math inline">\(\mu_i\)</span>:</p>
<p><span class="math display">\[\mu_{age = 45} =176.688 + 0.645 * 45\\ 
= 205.707\]</span></p>
<p>The predicted value is our best guess under the LRM model. Like coefficients, it is uncertain to some degree, but we are setting this aside for the moment. What we know for sure is the <em>observed value</em> . A primitive procedure to get a best guess for someone of age 45 is to find one matching case in the data and take this as face value. The data set contains a few of those participants, but the situation is rather scattered and the prediction is not clear.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(Part, age, ToT) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(age <span class="op">==</span><span class="st"> </span><span class="dv">45</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">Part</th>
<th align="right">age</th>
<th align="right">ToT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">28</td>
<td align="right">45</td>
<td align="right">153</td>
</tr>
<tr class="even">
<td align="right">68</td>
<td align="right">45</td>
<td align="right">168</td>
</tr>
<tr class="odd">
<td align="right">128</td>
<td align="right">45</td>
<td align="right">120</td>
</tr>
<tr class="even">
<td align="right">168</td>
<td align="right">45</td>
<td align="right">175</td>
</tr>
</tbody>
</table>
<p>A more disciplined way to obtain predicted values is to use the standard command <code>predict</code> on the model object:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_pred_age &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(Part, age, ToT) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">mu =</span> <span class="kw">predict</span>(M_age_shft)<span class="op">$</span>center)

T_pred_age <span class="op">%&gt;%</span><span class="st">  </span>
<span class="st">  </span><span class="kw">filter</span>(age <span class="op">==</span><span class="st"> </span><span class="dv">45</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">Part</th>
<th align="right">age</th>
<th align="right">ToT</th>
<th align="right">mu</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">28</td>
<td align="right">45</td>
<td align="right">153</td>
<td align="right">194</td>
</tr>
<tr class="even">
<td align="right">68</td>
<td align="right">45</td>
<td align="right">168</td>
<td align="right">192</td>
</tr>
<tr class="odd">
<td align="right">128</td>
<td align="right">45</td>
<td align="right">120</td>
<td align="right">194</td>
</tr>
<tr class="even">
<td align="right">168</td>
<td align="right">45</td>
<td align="right">175</td>
<td align="right">195</td>
</tr>
</tbody>
</table>
<!-- FIXME: They don't get the same predictions -->
<p>We see that all participants of age 45 get the same prediction. What differs is the observed value, as this contains the influence of all random sources at the time of measuring. We will return to residuals in the next section.</p>
<p>What if we wanted to get a best guess for an age that did not occur in our data set, say 43.5? Using the LR likelihood function above, we can estimate the expectation for any value we want. By entering the intercept and age estimates (<code>C_age</code>), we obtain:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">C_age &lt;-<span class="st"> </span><span class="kw">fixef</span>(M_age_shft)<span class="op">$</span>center
C_age[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span><span class="fl">43.5</span> <span class="op">*</span><span class="st"> </span>C_age[<span class="dv">2</span>]</code></pre></div>
<pre><code>## [1] 205</code></pre>
<p>With the same procedure, it is possible to plot observed and expected values next to each other:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">G_pred_age &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> age, <span class="dt">y =</span> ToT)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_abline</span>(<span class="dt">intercept =</span> C_age[<span class="dv">1</span>], 
              <span class="dt">slope =</span> C_age[<span class="dv">2</span>],
              <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)

G_pred_age</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/expected_values-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
<p>This figure does not look too convincing. The regression line is rather flat, indicating a small effect of age. In addition, it looks like a lonely highway in a vast forest area. Just visually, a completely flat line or a slight negative slope would be equally credible.</p>
<ul>
<li>resid-predict plots as a general form to discover trends</li>
<li>qq plots</li>
</ul>
</div>
<div id="exercises-2" class="section level3">
<h3><span class="header-section-number">5.2.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Examine the linear parameters of model <code>M_age_rtrn</code> and derive some impossible predictions, as was done in the previous section.</p></li>
<li><p>The BAB1 data set contains another outcome variable where the number of clicks was measured until the participant found the desired information. Specify a LR with age and examine the residual distribution. Is the Normality assumption reasonably defensible? What is the difference to home returns, despite both variables being counts?</p></li>
<li><p>Review the two figures in the first example of [GSR]. The observations are bi-modally distributed, nowhere near Gaussian. After (graphically) applying the model they are well-shaped. What does that tell you about checking residual assumptions before running the model?</p></li>
</ol>
</div>
</div>
<div id="CGM" class="section level2">
<h2><span class="header-section-number">5.3</span> A versus B: Comparison of groups</h2>
<p>Another basic liknear model is the <em>comparison of groups</em> (CGM), which replaces the commonly known analysis of variance (ANOVA). In design research group comparisons are all over the place, for example:</p>
<ul>
<li>comparing designs: as we have seen in the A/B testing scenario</li>
<li>comparing groups of people, like gender or whether they have a high school degree</li>
<li>comparing situations, like whether someone uses an app on the go, or sitting still behind a computer</li>
</ul>
<p>In order to perform a CGM, a variable is needed that establishes the groups. This is commonly called a <em>factor</em>. A factor is a variable that identifies members of groups, like “A” and “B” or “male” and “female”. The groups are called <em>factor levels</em>. In the BrowsingAB case, the prominent factor is Design with its levels A and B.</p>
<p>Asking for differences between two (or more) designs is routine in design research. For example, it could occur during an overhaul of a municipal website. With the emerge of e-government, many municipal websites have grown wildly over a decade. What once was a lean (but not pretty) 1990 website over time has grown into a jungles, to the disadvantage for the users. The BrowsingAB case could represent the prototype of a novel web design, which is developed and tested via A/B testing at 200 users. Every user is given the same task, but sees only one of the two designs. The design team is interested in: <em>do two web designs A and B differ in user performance?</em></p>
<p>Again, we first take a look at the raw data:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> ToT)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_histogram</span>() <span class="op">+</span>
<span class="st">    </span><span class="kw">facet_grid</span>(Design<span class="op">~</span>.)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/eda_anova-1.png" width="672" /></p>
<p>This doesn’t look too striking. We might consider a slight advantage for design B, but the overlap is immense. We perform the CGM. Again, this is a two-step procedure:</p>
<ol style="list-style-type: decimal">
<li>the <code>stan_glm</code> command lets you specify a simple formula to express the dependency between predictors (education) and outcome variable (ToT). It performs the parameter estimation, using the method of <em>Markov-Chain Monte-Carlo Sampling</em>. The results are stored in a new object <code>M_Design</code>.</li>
<li>With the <code>fixef</code> command the estimates are extracted and interpreted</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_Design &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>Design, 
           <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_Design &lt;-<span class="st"> </span><span class="kw">fixef</span>(M_Design)
T_Design</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">203</td>
<td align="right">194.7</td>
<td align="right">212.21</td>
</tr>
<tr class="even">
<td align="left">DesignB</td>
<td align="right">-15</td>
<td align="right">-27.4</td>
<td align="right">-3.05</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
<p>The model contains two parameters, the first one being the <em>intercept</em>, again. How can you have a “crossing point zero”, when there is no line, but just two groups. You can’t. When speaking of pure factor models, like the one above or the multifactorial models of the next section, the intercept has a different meaning, it is the <em>mean of a reference group</em>. Per default, stan_glm chooses the alphabetically first group label as the reference group, design A. We can therefore say that design A has an average performance of <span class="math inline">\(203.36 [194.7, 212.21]_{CI95}\)</span>.</p>
<p>The second parameter is the effect of “moving to design B”. It is given as the <em>difference to the reference group</em>. With design B it took users <span class="math inline">\(15.02 [27.36, 3.05]_{CI95}\)</span> less time to complete the task. This effect appears rather small and there is huge uncertainty about it. It barely justifies the effort to replace design A with B. If the BrowsingAB data set has some exciting stories to tell, the design difference is not it.</p>
<div id="dummy_variables" class="section level3">
<h3><span class="header-section-number">5.3.1</span> Not stupid: dummy variables</h3>
<p>Are we missing something so far? We have not seen the model formula, yet. The CGM is a linear model, but this is not so apparent as it contains a factor, a non-metric variable. Linear model terms are a sum of products <span class="math inline">\(\beta_ix_i\)</span>, but factors cannot just enter such a term. What would be the result of <span class="math inline">\(\mathrm{DesignB} \times\beta_1\)</span>?</p>
<p><em>Factors</em> basically answer the question: <em>What group does the observation belong to?</em>. This is a label, not a number, and cannot enter the regression formula. <em>Dummy variables</em> solve the dilemma by converzing factor levels to numbers. A dumma variable represents only one level of a factor, by asking the simple question: <em>Does this observation belong to group DesignB?</em> The answer is yes/no and can be coded by a Boolean variable. For every level, a separate dummy variable is constructed to answer the simple yes/no question of membership. But, can Boolean variables enter arithmetic equations? At least, R assumes that this is safe, as they can always be converted to ones and zeros using <code>as.numeric</code>. Routinely, we can leave the whole dummy variable business to the linear model engine. Still, it is instructive to do it yourself once.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 &lt;-<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">d_A =</span> <span class="kw">as.numeric</span>(Design <span class="op">==</span><span class="st"> &quot;A&quot;</span>),
         <span class="dt">d_B =</span> <span class="kw">as.numeric</span>((Design <span class="op">==</span><span class="st"> &quot;B&quot;</span>)))
BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(Obs, Design, d_A, d_B, ToT) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">sample_n</span>(<span class="dv">8</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">Obs</th>
<th align="left">Design</th>
<th align="right">d_A</th>
<th align="right">d_B</th>
<th align="right">ToT</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">101</td>
<td align="left">B</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">283</td>
</tr>
<tr class="even">
<td align="right">169</td>
<td align="left">B</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">195</td>
</tr>
<tr class="odd">
<td align="right">170</td>
<td align="left">B</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">174</td>
</tr>
<tr class="even">
<td align="right">112</td>
<td align="left">B</td>
<td align="right">0</td>
<td align="right">1</td>
<td align="right">181</td>
</tr>
<tr class="odd">
<td align="right">43</td>
<td align="left">A</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">190</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">A</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">247</td>
</tr>
<tr class="odd">
<td align="right">42</td>
<td align="left">A</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">252</td>
</tr>
<tr class="even">
<td align="right">19</td>
<td align="left">A</td>
<td align="right">1</td>
<td align="right">0</td>
<td align="right">228</td>
</tr>
</tbody>
</table>
<p>Vice versa, numbers in a logical context are always interpreted in complete reverse.</p>
<p><span class="math display">\[ 
v = 1 \mapsto \mathrm{TRUE}\\ v = 0 \mapsto \mathrm{FALSE} 
\]</span></p>
<p>Boolean variables can be used in all contexts, including numerical and categorical. It is unfortunate that we call them dummies in such a belittling manner, as they are truly bridges between the world of categories and arithmetic. They identify groups in our data set and switch on or off the effect in the linear term. For a factor G with levels A and B and zero/one-coded dummy variables <code>d_A</code> and <code>d_B</code>, the likelihood is written as:</p>
<p><span class="math display">\[ 
\mu_i = d_{Ai} \beta_{A} + d_B \beta_{Bi} 
\]</span></p>
<p>When <span class="math inline">\(d_{Ai}=1, d_{Ai}=0\)</span>, the parameter <span class="math inline">\(\beta_A\)</span> is switched on, and <span class="math inline">\(\beta_B\)</span> is switched off. An observation of group A gets the predicted value: <span class="math inline">\(\mu_i = \beta_A\)</span>, vice versa for members of group B. All arithmetic commands in R do an implicit typecast when encountering a Boolean variable, e.g. <code>sum(TRUE, FALSE, TRUE)</code> (the result is 2). In contrast, regression engines interpret Boolean variables as categorical. Therefore, dummy variables have to be passed on as explicitly numeric to the regression engine. Only when a variables truly is zeroes and ones, it will be interpreted as desired. This has been done that with the explicit typecast <code>as.numeric</code> above.</p>
<p>Most research deals with estimating effects as differences and all regression engines quietly assume that what you want is a model with a reference group. When expanding the dummy variables manually, this automatism gets into the way and the needs to be switched off, explicitly. In Rs linear models formula language, that is done by adding the term <code>0 +</code> to the formula.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_dummy &lt;-
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">0</span> <span class="op">+</span><span class="st"> </span>d_A <span class="op">+</span><span class="st"> </span>d_B, 
     <span class="dt">data =</span> BAB1)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fixef</span>(M_dummy)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">d_A</td>
<td align="right">203</td>
<td align="right">194</td>
<td align="right">213</td>
</tr>
<tr class="even">
<td align="left">d_B</td>
<td align="right">188</td>
<td align="right">179</td>
<td align="right">197</td>
</tr>
</tbody>
</table>
<p>In its predictions, the model <code>M_dummy</code> is equivalent to the fomer model <code>M_design</code>, but contains two effects that are exactly the group means. This model we call an <em>absolute group means model (AGM)</em>.</p>
<p>Regression engines expand dummy variables automatically, when they encounter a factor. However, when formally specifying the likelihood, dummy variables must be made explicit. When doing an AGM on a factor <span class="math inline">\(x_1\)</span> with <span class="math inline">\(1,...,k\)</span> levels, the likelihood function becomes:</p>
<p><span class="math display">\[\mu_i=d_1 \beta_{1[1]}+...+d_k \beta_{1[k]}\]</span></p>
<p>In the remainder of the book, we are dealing with more complex models (e.g., multifactorial models in the next section), as well as factors with many levels (random effects in multi-level models <a href="multilevel-models.html#multilevel-models">6</a>). With expanded dummy variables, the likelihood can become unduly long. However, many other textbooks avoid this altogether and the model is unambiguously specified in Rs regression formula language.</p>
<p>Up to this point, I have introduced dummy variables at the example of AGMs, where at any moment only one factor level is switched on. A more common CGMs would have a the following likelihood specification (with a factor of <span class="math inline">\(k\)</span> levels):</p>
<p><span class="math display">\[\mu_i = \beta_0 + d_1 \beta_{1[1]}+...+d_k \beta_{1[k-1]}\]</span></p>
<p>For a factor with <span class="math inline">\(k\)</span> levels in a CGM with intercept, <span class="math inline">\(k-1\)</span> dummy variables need to be constructed in the way shown above. As all non-reference levels are seen as difference towards the reference, <em>the reference level is set to always on</em>. To see so, we extract the dummy variables from the CGM on design with the standard command <code>model.matrix</code>. As you can see, for all observations the <code>(Intercept)</code> column takes the value <code>1</code>, whereas level <code>DesignB</code> is switched on and off.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(Part, Design, ToT) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">cbind</span>(<span class="kw">model.matrix</span>(M_Design)) <span class="op">%&gt;%</span><span class="st"> </span>## &lt;---
<span class="st">  </span><span class="kw">as_data_frame</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">sample_n</span>(<span class="dv">8</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right">Part</th>
<th align="left">Design</th>
<th align="right">ToT</th>
<th align="right">(Intercept)</th>
<th align="right">DesignB</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">139</td>
<td align="left">B</td>
<td align="right">180</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">78</td>
<td align="left">A</td>
<td align="right">220</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">30</td>
<td align="left">A</td>
<td align="right">268</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">46</td>
<td align="left">A</td>
<td align="right">245</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">60</td>
<td align="left">A</td>
<td align="right">237</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td align="right">75</td>
<td align="left">A</td>
<td align="right">211</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td align="right">154</td>
<td align="left">B</td>
<td align="right">194</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">194</td>
<td align="left">B</td>
<td align="right">169</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>Regression engines take care of factors, automatically, expanding the dummy variables under the hood. Still, by understanding the concept, we gained additional flexibility in specifying factorial models. One variant is to estimate an AGM, which leaves out the intercept. Of course, this can also be done right-away with the formula <code>ToT ~ 0 + Design</code>. Later, we will see a very practical application of AGMs, when drawing interaction plots. The second benefit is that we can specify the reference level as we want. It just depends on which dummy variable one sets to always-on. In the next section we will gain even more control over what the effects mean, by setting contrasts.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
</div>
<div id="contrasts" class="section level3">
<h3><span class="header-section-number">5.3.2</span> Getting it sharper with contrasts [TBC]</h3>
<p>The default behavior of regression engines when encountering a factor is to select the first level as reference group and estimate all other levels relative to that. This fully makes sense when you are after the effect of a treatment and is therefore called <em>treatment contrasts</em>. Treatment contrasts do not have anything special to them. They are just a default of the regression engines, because so many people work experimentally.</p>
<p>Before we come to an understanding what contrasts are, let me point out what they are not: In @ref(dummy_variables) it was mentioned, that the AGM and CGM make exactly the same predictions (even though the formulas differ by the <code>+0</code> term). For contrasts, this holds in general. Setting contrasts never changes the predictions <span class="math inline">\(\mu_i\)</span>. In contrast, <em>contrast change what the coefficients <span class="math inline">\(\beta_i\)</span> mean</em>. Recall, that in an CGM, <span class="math inline">\(\beta_1\)</span> has the meaning of “difference to the reference group”, whereas in an AGM, it is “the mean of the second group”.</p>
<p>In the following, I will illustrate contrasts that represent two different types of questions:</p>
<ul>
<li>To what extent does a group deviate from the overall mean in the sample?</li>
<li>With three ordered factor levels, how large is the rolling effect, i.e. from level 1 to level 2, and the average of 1 and 2 to level 3?</li>
</ul>
<p>So, how are contrasts set? Although, this is a bit odd, they are neither set by modifications to the regression formula, nor by additional command arguments. Instead, <em>contrasts are set as attributes of the factor variable</em>, which we can retrieve by and set by the standard command <code>contrasts</code>. For example, the variable Education has the three levels “Low”, “Middle”, “High”, in that order:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">levels</span>(BAB1<span class="op">$</span>Education)</code></pre></div>
<pre><code>## [1] &quot;Low&quot;    &quot;Middle&quot; &quot;High&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">contrasts</span>(BAB1<span class="op">$</span>Education) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">Middle</th>
<th align="right">High</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Low</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Middle</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>High</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>If you believe to have seen something similar before, you are right. Contrast tables are related to dummy variables (@ref(dummy_variables)). The column Low is omitted in the contrasts table as it is the reference level with an always-on intercept. In the previous section I mentioned that you can choose the reference level freely by constructing the dummy variables accordingly. However, that would mean to always bypass the regression engines dummy handling. The package <code>forcats</code> provides a set of commands to change the order of levels. In the following code, the factor levels are reversed, such that High becomes the reference group:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Education_rev =</span> forcats<span class="op">::</span><span class="kw">fct_rev</span>(Education)) <span class="co"># &lt;--</span>
<span class="kw">levels</span>(BAB1<span class="op">$</span>Education_rev)</code></pre></div>
<pre><code>## [1] &quot;High&quot;   &quot;Middle&quot; &quot;Low&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">contrasts</span>(BAB1<span class="op">$</span>Education_rev) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">Middle</th>
<th align="right">Low</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>High</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Middle</td>
<td align="right">1</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>Low</td>
<td align="right">0</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
<p>If we were running a CGM on <code>Education_rev</code>, the intercept would represent level High, now. Again, this model would make the very same predictions and residuals. In that respect, it is the same model as before, only the meaning (and values) of the coefficients changes and become differences to the level High.</p>
<p>Sometimes, it is useful to have contrasts other than treatment, as this more closely matches the research question. A plethora of contrasts is known, I will introduce <em>deviation contrasts</em> and <em>successive difference contrasts</em> in the following.</p>
<p>[Example for deviation coding]</p>
<p><em>Successive difference coding (SDC)</em> applies when one is interested in effects of progressive effects, such as performance gain in a number of sessions. Consider the following research situation. Shortly after the millennium, medical infusion pumps became infamous for killing people. Infusion pumps are rather simple devices that administer medication to a patients body in a controlled manner. Being widely used in surgery and intensive care, development of these devices must comply to national and international regulations. Unfortunately, the regulations of those days almost completely overlooked the human factor. While those devices would always function “as described in the user manual”, they contained all kinds of severe violations of user-interface design rules, just to name few: foil switches with poor haptic feedback, flimsy alphanumeric LCD screenlets and a whole bunch of modes. Imagine a medical devices company has partnered with some renowned research institute to develop the infusion pump of the future. Users got interviewed and observed, guidelines were consulted, prototypes developed, tested and improved. At the end of the process the design was implemented as an interactive simulation. In the meantime, national agencies had reacted, too, and regulations now demand a routine user-oriented development cycle. One of the new rules says: “the design must undergo validation testing with trained users”.</p>
<p>That means you have to first introduce and train your users to get fluent with the device, then test them. We [REF] thought that the training process itself is of immense importance. Why not test it, then? In the real study we tested everyone three times and traced individual progress. This requires a repeated measures analysis and we are not quite there, yet [see LMM].</p>
<p>[TODO:</p>
<ul>
<li><p>simulate IPump case, non-repeated</p></li>
<li><p>demonstrate succ diff contr</p></li>
<li><p>find example for deviation contrasts</p></li>
<li><p>Contrasts extend the idea of dummy variables.</p></li>
<li><p>Dummy variables become continuous, thereby more flexible in their effects</p></li>
</ul>
<p>]</p>
</div>
<div id="sharper-on-the-fly-derived-quantities-tbd" class="section level3">
<h3><span class="header-section-number">5.3.3</span> Sharper on the fly: derived quantities [TBD]</h3>
<p>Contrasts are classic in aligning regression estimates with research questions that state a differences. With two groups A and B the following hypotheses of difference can be formed:</p>
<pre><code>A - 0
B - 0
A - B</code></pre>
</div>
<div id="exercises-3" class="section level3">
<h3><span class="header-section-number">5.3.4</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>The <code>simulate</code> function in case environment BrowsingAB lets you change the residual error (in standard deviations). Simulate three data sets with different residual variance, and estimate them by the same model. See how the uncertainty of effects behaves.</p></li>
<li><p>BrowsingAB, simulate several data sets of very small sample size. Observe how strongly the composition of education and age varies.</p></li>
<li><p>BAB1 contains the variable Education, which separates the participants by three education level (Low, Middle, High). Construct the dummy variables and run an AGM.</p></li>
<li><p>Specify the expanded CGM likelihood for education. Construct the dummy variables and run a regression.</p></li>
<li><p>Consider you wanted to use education level High as reference group. Create dummy variables accordingly and run the regression.</p></li>
</ol>
</div>
</div>
<div id="putting-it-all-together-multi-predictor-models" class="section level2">
<h2><span class="header-section-number">5.4</span> Putting it all together: multi predictor models</h2>
<p>Design researchers are often forced to obtain their data under rather wild conditions. Users of municipal websites, consumer products, enterprise information systems and cars can be extremely diverse. At the same time, Designs vary in many attributes, affecting the user in many different ways. There are many variables in the game, and even more possible relations. With <em>multi predictor models</em> we can examine the simultaneous influence of everything we have recorded. First, we will see, how to use models with two or more metric covariates. Subsequently, we address the case of multi-factorial designs. Finally, we will see examples of models, where covariates and factors peacefully co-reside.</p>
<div id="on-surface-multiple-regression-models" class="section level3">
<h3><span class="header-section-number">5.4.1</span> On surface: multiple regression models</h3>
<p>Productivity software, like word processors, presentation and calculation software or graphics programs have evolved over decades. For every new release, dozens of developers have worked hard to make the handling more efficient and the user experience more pleasant. Consider a program for drawing illustrations: basic functionality, such as drawing lines, selecting objects, moving or colorize them, have practically always been there. A user wanting to draw six rectangles, painting them red and arranging them in a grid pattern, can readily do that using basic functionality. At a certain point of system evolution, it may have been recognized that this is what users routinely do: creating a grid of alike objects. With the basic functions this is rather repetitive and a new function was created, called “copy-and-arrange”. Users may now create a single object, specify rows and columns of the grid and give it a run.</p>
<p>The new function saves time and leads to better results. Users should be very excited about the new feature, should they not? Not right so, as [Carroll in Rosson] made a very troubling observation: adding functionality for the good of efficiency may turn out ineffective in practice, as users have a strong tendency to stick with their old routines, ignoring new functionality right away. This troubling observation has been called the <em>active user paradox (AUP)</em>.</p>
<p>Do all users behave that way? Or can we find users of certain traits that are involved. What type of person would be less likely to fall for the AUP? And how can we measure resistance towards the AUP? We did a study, where we explored the impact of two user traits <em>need-for-cognition (ncs)</em> and <em>geekism (gex)</em> on AUP resistance. To measure AUP resistance we observed users while they were doing drawing tasks. A moderately complex behavioral coding system was used to derive an individual AUP resistance score. Are users with high need-for-cognition and geekism more explorative and resistant to the AUP?</p>
<p>As we will see later, it is preferable to build a model with two simultaneous predictors. For instructive purposes we begin with two separate LRM, one for each predictor. Throughout the regression models we use z-transformed scores. Neither the personality nor the resistance scores have a natural interpretation, so nothing is lost in translation.</p>
<p><span class="math display">\[
\mu_i = \beta_0 + \beta_\mathrm{ncs} x_\mathrm{ncs}\\
\mu_i = \beta_0 + \beta_\mathrm{gex} x_\mathrm{gex}
\]</span></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(AUP)
M_<span class="dv">1</span> &lt;-<span class="st"> </span>
<span class="st">  </span>AUP_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(zresistance <span class="op">~</span><span class="st"> </span>zncs, <span class="dt">data =</span> .)

M_<span class="dv">2</span> &lt;-<span class="st"> </span>
<span class="st">  </span>AUP_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(zresistance <span class="op">~</span><span class="st"> </span>zgex, <span class="dt">data =</span> .)
<span class="kw">detach</span>(AUP)</code></pre></div>
<p>@ref(tab:AUP_coef) shows the two separate effects (<code>M_1</code> and <code>M_2</code>). Due to the z-transformation of predictors, the intercepts are practically zero. Both personality scores seem to have a weakly positive impact on AUP resistance.</p>
<p>Next, we estimate a model that regards both predictors simultaneously. For linear models, that requires nothing more than to make a sum of all involved predictor terms (and the intercept). The result is a <code>multiple regression model (MRM)</code>:</p>
<p><span class="math display">\[
\mu_i = \beta_0 + \beta_\mathrm{ncs} x_\mathrm{ncs} + \beta_\mathrm{gex} x_\mathrm{gex}
\]</span></p>
<p>In Rs regression formula language, this likewise straight-forward. The <code>+</code> operator directly corresponds with the <code>+</code> in the likelihood formula.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(AUP)
M_<span class="dv">3</span> &lt;-<span class="st"> </span>
<span class="st">  </span>AUP_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(zresistance <span class="op">~</span><span class="st"> </span>zncs <span class="op">+</span><span class="st"> </span>zgex, <span class="dt">data =</span> .) <span class="co">#&lt;--</span>

<span class="kw">detach</span>(AUP)</code></pre></div>
<p>For the comparison of the three models we make use of a feature of the package bayr: the posterior distributions of arbitrary models can be combined into one multi-model posterior object, by just stacking them upon each other. The coefficient table of such a multi-model posterior gains an additional column that identifies the model:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(AUP)

P &lt;-
<span class="st">  </span><span class="kw">bind_rows</span>(<span class="kw">posterior</span>(M_<span class="dv">1</span>),
            <span class="kw">posterior</span>(M_<span class="dv">2</span>),
            <span class="kw">posterior</span>(M_<span class="dv">3</span>))

T_coef_<span class="dv">3</span> &lt;-<span class="st"> </span>P <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">posterior</span>() <span class="op">%&gt;%</span><span class="st">  </span>
<span class="st">  </span><span class="kw">fixef</span>()
T_coef_<span class="dv">3</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_1</td>
<td align="left">Intercept</td>
<td align="right">0.005</td>
<td align="right">-0.308</td>
<td align="right">0.306</td>
</tr>
<tr class="even">
<td align="left">M_1</td>
<td align="left">zncs</td>
<td align="right">0.377</td>
<td align="right">0.054</td>
<td align="right">0.699</td>
</tr>
<tr class="odd">
<td align="left">M_2</td>
<td align="left">Intercept</td>
<td align="right">-0.004</td>
<td align="right">-0.312</td>
<td align="right">0.311</td>
</tr>
<tr class="even">
<td align="left">M_2</td>
<td align="left">zgex</td>
<td align="right">0.298</td>
<td align="right">-0.029</td>
<td align="right">0.605</td>
</tr>
<tr class="odd">
<td align="left">M_3</td>
<td align="left">Intercept</td>
<td align="right">0.001</td>
<td align="right">-0.306</td>
<td align="right">0.317</td>
</tr>
<tr class="even">
<td align="left">M_3</td>
<td align="left">zncs</td>
<td align="right">0.300</td>
<td align="right">-0.090</td>
<td align="right">0.686</td>
</tr>
<tr class="odd">
<td align="left">M_3</td>
<td align="left">zgex</td>
<td align="right">0.121</td>
<td align="right">-0.273</td>
<td align="right">0.508</td>
</tr>
</tbody>
</table>
<p>The intercepts of all three models are practically zero, which is a consequence of the z-transformation. Recall, that the intercept in an LRM is the predicted value, when the predictor is zero. In MRM this is just the same: here, the intercept is the predicted AUP resistance score, for when NCS and GEX are both zero.</p>
<p>When using the two predictors simultaneously, the overall positive tendency remains. However, we observe major and minor shifts: in the MRM, the strength of the geekism score is reduced to less than half: <span class="math inline">\(0.12 [-0.27, 0.51]_{CI95}\)</span>. NCS has shifted, too, but lost only little of its original strength: <span class="math inline">\(0.3 [-0.09, 0.69]_{CI95}\)</span>.</p>
<p>For any researcher who has carefully conceived research questions that appears to be a disappointing outcome. In fact, there is a reason for the loss of strength and ignoring this issue will mislead the interpretation of results.</p>
<p>The reason is that the two <em>predictors are correlated</em>. In this study, participants who are high on NCS also tend to have more pronounced geekism. @ref(AUP_corr_predictors) reveals the situation:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">G_eda_<span class="dv">4</span> &lt;-<span class="st"> </span>
<span class="st">  </span>AUP_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> zncs, <span class="dt">y =</span> zgex)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">se =</span> F) <span class="op">+</span>
<span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="kw">str_c</span>(<span class="st">&quot;Correlation between ncs and gex: &quot;</span>, 
              <span class="kw">round</span>(<span class="kw">cor</span>(AUP_<span class="dv">1</span><span class="op">$</span>zncs, AUP_<span class="dv">1</span><span class="op">$</span>zgex), <span class="dv">2</span>)))

G_eda_<span class="dv">4</span></code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/AUP_corr_predictors-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(AUP)</code></pre></div>
<p>Participants with a higher NCS also tend to have more geekism. Is that surprising? Actually, it is not. People high on NCS love to think. Computers are a good choice for them, because these are complicated devices that make you think. (Many users may even agree that computers help you think, for example when analyzing your data with R.) In turn, geekism is a positive attitude towards working with computers in sophisticated ways, which means such people are more resistant towards the AUP.</p>
<p>[NCS: love to think] –&gt; [GEX: love computers] –&gt; [resist AUP]</p>
<p>When such a causal chain can be established, some researchers speak of a <em>mediating variable</em> GEX. Although a bit outdated [REF], <em>mediator analysis is correct when the causal direction of the three variables is known</em>. Then, a so-called step-wise regression is performed to find the pure effects. (A better alternative is structural equation modelling, SEM).</p>
<p>Unfortunately, in the situation here, the causal direction is partly ambiguous. We can exclude that the resistance test has influenced the personality scores, because of the order of apperance in the study. But, causally speaking, geekism may well preceed NCS. For example, computers reward you for thinking hard and, hence, you get used to it and make it your lifestyle. If you like thinking hard, then you probably also like the challenge that was given in the experiment.</p>
<p>[GEX: love computers] –&gt; [NCS: love to think] –&gt; [resist AUP]</p>
<p>In the current case, we can not distinguish between these two competing theories by data alone. This is a central problem in empirical research. An example, routinely re-iterated in social science methods courses is the observation that people who are more intelligent tend to consume more fresh vegetables. Do carrots make us smart? Perhaps, but it is equally plausible that eating carrots is what smart people do.</p>
<p>The issue is that a particular direction of causality can only be established, when all reverse directions can be excluded. Behavioural science reseachers know of only two ways to do so:</p>
<ol style="list-style-type: decimal">
<li>By the <em>arrow of time</em>, it is excluded that a later event caused a preceding one. In the AUP study, there is no doubt that filling out the two personality questionnaires cause the behaviour in the computer task, because of the temporal order.</li>
<li>In <em>strictly controlled experiments</em>, participants are assigned to the conditions, randomly. That has (virtually) happened in the BrowsingAB case, which gives it an unambiguous causal direction. This was not so, if participants had been allowed to choose themselves which design to test.</li>
</ol>
<p>To come back to the AUP study: There is no way to establish a causal order of predictors. The correct procedure is to regard the predictors simultaneously (not step-wise), as in model <code>M_3</code>. This results in a redistribution of the overall covariance and the predictors are <em>mutually controlled</em>. In <code>M_2</code> the effect of GEX was promising at first, but then became spurious in the simultaneous model. Most of the strength was just borrowed from NCS by covariation. The model suggests that loving-to-think has a quite stronger association with AUP resistance than loving-computers.</p>
<p>That <em>may</em> suggest, but not prove, that geekism precedes NCS, as in a chain of causal effects, elements that are closer to the final outcome (AUP resistance), tend to exert more salient influence. But, without further theorizing and experimenting this is weak evidence of causal order.</p>
<p>The readers of a paper on geekism, NCS and the AUP will probably be more impressed by the (still moderate) effects in the separate models we had run, initially. The reason why one should not do that is that separate analyses suggest that the predictors are independent. To illustrate this at an extreme example, think of a study where users were asked to rate their agreement with an interface by the following two questions, before ToT is recorded:</p>
<ol style="list-style-type: decimal">
<li>The interface is beautiful</li>
<li>The interface has an aesthetic appearance?</li>
</ol>
<p>Initial separate analysis shows strong effects for both predictors. Still, it would not make sense to give the report the title: “Beauty and aesthetics predict usability”. Beauty and aesthetics are practically synonyms. For Gex and NCS this may be not so clear, but we cannot exclude the possibility that they are linked to a common factor, perhaps a third trait that makes people more explorative, no matter whether it be thoughts or computers.</p>
<p>So, what to do, when two predictors correlate strongly? First, we always report just a single model. Per default, this is the model with both predictors, simultaneously. The second possibility is to use a disciplined method of <em>model selection</em> @ref(model_selection) and remove this (or those) predictors that do not actually contribute to prediction. The third possibility is, that the results with both predictors become more interesting when including interaction effects @ref(interaction_effects)</p>
</div>
<div id="crossover-multifactorial-models-tbc" class="section level3">
<h3><span class="header-section-number">5.4.2</span> Crossover: multifactorial models [TBC]</h3>
<p>The only necessary precondition for statistical control is that you recorded the influencing variable. This has happened in the BrowsingAB study: the primary research question regarded the design difference, but the careful researcher also recorded the gender of participants.</p>
<p>What happened to the likelihood function when we moved from GMM to CGM and LRM? The effect of age was simply added to the intercept. For model on education level effects, we expanded the dummy variables and then added them all up. Indeed, the linear model is defined as a succession of linear terms <span class="math inline">\(x_i\beta_i\)</span> and nothing keeps us from adding further predictors to the model. Seeing is believing! The following code estimates a model with design and gender as predictors.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_mpm_<span class="dv">1</span> &lt;-<span class="st"> </span>
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span>Design <span class="op">+</span><span class="st"> </span>Gender, <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_fixef_mpm_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">fixef</span>(M_mpm_<span class="dv">1</span>)
T_fixef_mpm_<span class="dv">1</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">203.349</td>
<td align="right">191.9</td>
<td align="right">215.10</td>
</tr>
<tr class="even">
<td align="left">DesignB</td>
<td align="right">-15.050</td>
<td align="right">-27.8</td>
<td align="right">-2.68</td>
</tr>
<tr class="odd">
<td align="left">GenderM</td>
<td align="right">0.196</td>
<td align="right">-12.8</td>
<td align="right">12.71</td>
</tr>
</tbody>
</table>
<p>By adding gender to the model, both effects are estimated simultaneously. In a <em>factorial MPM</em> the intercept is a reference group, too. Consider that both factors have two levels, forming a <span class="math inline">\(2x 2\)</span> design with groups: A-F, A-M, B-F, B-M. The first one, A-F, has been set as reference group. Women in condition A have an average ToT of <span class="math inline">\(203.35 [191.94, 215.1]_{CI95}\)</span> seconds. The other two fixed effects are, once again, differences to the reference. Here, nor does gender do much to performance, nor does the design effect really change, compared to the CGM.</p>
<p>[likelihood][interaction plot]</p>
</div>
<div id="line-by-line" class="section level3">
<h3><span class="header-section-number">5.4.3</span> Line-by-line: regression in groups [TBC]</h3>
<p>Recall that dummy variables make factors compatible with linear regression. No barriers are left for combining factors and covariates in one model. For example, we can estimate the effects age and design simultaneously:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_mpm_<span class="dv">2</span> &lt;-<span class="st"> </span>
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span>Design <span class="op">+</span><span class="st"> </span>age_shft, <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_fixef_mpm_<span class="dv">2</span> &lt;-<span class="st">  </span><span class="kw">fixef</span>(M_mpm_<span class="dv">2</span>)
T_fixef_mpm_<span class="dv">2</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">184.208</td>
<td align="right">169.940</td>
<td align="right">198.79</td>
</tr>
<tr class="even">
<td align="left">DesignB</td>
<td align="right">-14.981</td>
<td align="right">-27.804</td>
<td align="right">-2.14</td>
</tr>
<tr class="odd">
<td align="left">age_shft</td>
<td align="right">0.648</td>
<td align="right">0.254</td>
<td align="right">1.03</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
<p>Once again, we get an intercept, first. Recall, that in LRM the intercept is the the performance of a 20-year old (age shifted). In GCM it was the mean of the reference group. When <em>marrying factors with a covariates, the intercept is point zero in the reference group</em>. The predicted average performance of 20-year old with design A is <span class="math inline">\(184.21 [169.94, 198.79]_{CI95}\)</span>. The age effect has the usual meaning: by year of life, participants get <span class="math inline">\(0.65 [0.25, 1.03]_{CI95}\)</span> seconds slower. The <em>factorial effect</em> B is a <em>vertical shift of the intercept</em>. 20-year old in condition B are <span class="math inline">\(14.98 [27.8, 2.14]_{CI95}\)</span> seconds faster. In fact, this holds for all ages, as can be seen in the following figure. The model implies that the age affect is the same with both designs, which is not true, as we will see later.</p>
<p>[likelihood][interaction plot]</p>
</div>
<div id="residual-analysis" class="section level3">
<h3><span class="header-section-number">5.4.4</span> Residual analysis</h3>
<div id="resid_predictive_power" class="section level4">
<h4><span class="header-section-number">5.4.4.1</span> Assessing predictive power</h4>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<p>When residuals are pronounced, predictions are inaccurate, which is undesireable. A model that reduces the residuals, may provide better predictions. In the current case, we may wonder: does the age predictor effectively reduce the residual standard error <span class="math inline">\(\sigma_\epsilon\)</span> as compared to the GMM? We fit the GMM for comparison purposes and compare the standard error. This does not look convincing, as the reduction is marginal.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_<span class="dv">0</span> &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bind_rows</span>(
  <span class="kw">posterior</span>(M_<span class="dv">0</span>),
  <span class="kw">posterior</span>(M_age_cntr)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">coef</span>(<span class="dt">type =</span> <span class="st">&quot;disp&quot;</span>)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_0</td>
<td align="right">46.1</td>
<td align="right">42.0</td>
<td align="right">51.2</td>
</tr>
<tr class="even">
<td align="left">M_age_cntr</td>
<td align="right">45.2</td>
<td align="right">41.1</td>
<td align="right">49.9</td>
</tr>
</tbody>
</table>
<p>Does the age variable really have that little predictive value? Seeing is believing. The following graph shows the individual residuals for both models as a column plot. The two caterpillars have about the same overall width and there is no noticable reduction in residual magnitude by adding the age predictor.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_resid &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(Obs, age) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(
    <span class="dt">M_0 =</span> <span class="kw">residuals</span>(M_<span class="dv">0</span>),
    <span class="dt">M_age =</span> <span class="kw">residuals</span>(M_age))

G_resid_age_<span class="dv">1</span> &lt;-
<span class="st">  </span>T_resid <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Obs_ordered =</span> <span class="kw">min_rank</span>(age)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(model, error, <span class="op">-</span>Obs, <span class="op">-</span>Obs_ordered, <span class="op">-</span>age) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> Obs, <span class="dt">y =</span> error)) <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(<span class="op">~</span>model) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_col</span>(<span class="dt">position =</span> <span class="st">&quot;dodge&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_quantile</span>()
G_resid_age_<span class="dv">1</span></code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/BAB1_resid_age_1-1.png" width="672" /></p>
<p>When adding a predictor to a model, the least one would expect is a noticable reduction in error and @ref(BAB1_resid_age_1) confirms that the age predictor is pretty useless.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
</div>
<div id="resid_normality" class="section level4">
<h4><span class="header-section-number">5.4.4.2</span> Normal distribution</h4>
<p>So far, we have seen two linear models, the GMM and the LRM. They only differ in how they sketch the relation between predictor variables and predicted values. In the remainder of this chapter on linear models, we will encounter a few more building blocks for the likelihood part and these will allow us to specify a wealth of complex models. However, the random term will stoically stay the same:</p>
<p><span class="math display">\[y_i \sim N(\mu_i, \sigma_\epsilon)\]</span></p>
<p>In words, the random term says: <em>observed values <span class="math inline">\(y_i\)</span> are drawn from a Normal distribution with the predicted value <span class="math inline">\(\mu_i\)</span> as mean and a fixed standard deviation <span class="math inline">\(\sigma_\epsilon\)</span></em>. As we have seen in <a href="bayesian-statistics.html#distributions">3.4.2</a>, Normal distributions are one pattern of randomness among many and this choice may therefore be appropriate, or not. One heuristic that may justify this choice is that the observed values are located rather in the center of the scale of measurement. That is certainly much better, than to blindly stick to the Normal random pattern just for convenience. Even better is to check the assumption of Normally distributed randomness. In the following, we will examine the underlying assumptions closer and apply graphical techniques for verification. Before we delve into more depth, I would like to contrast the overall tenor in this section (and [MODSEL]) to the workflow frequently encountered in classic statistics. Boldly speaken, classicically trained researchers often sem to imply, that such assumptions needed to be checked beforehand. In the process called <em>assumption checking</em>, arcane non parametric tests are carried out, before the researcher actually dares to hit the button labelled as <em>RUN ANOVA</em>. As we will see now, the order of actions is just the other way round. In the workflow called <em>model criticism</em>, we start by contemplating what may be a reasonable model, using heuristics or even past data. Then the model is immediatly executed and the estimated model itself undergoes a routine checkup. In linear models, verifying the random pattern assumptions grounds on extracting the estimated residuals from the model object and is hence called <em>residual analysis</em>.</p>
<p>In the notation displayed above, there are possibly as many distributions as there are observed values (due the subscript in <span class="math inline">\(\mu_i\)</span>). It appears impossible to evaluate not just one distribution but such many. However, an equivalent notation is routinely used for linear models, that specifies just one <em>residual distribution</em>. For the LRM that is:</p>
<p><span class="math display">\[
\mu_i = \beta_0 + \beta_1x_1\\
y_i = \mu_i + \epsilon_i\\
\epsilon_i \sim N(0, \sigma_\epsilon)
\]</span></p>
<p>In this notation, observed values <span class="math inline">\(y_i\)</span> are decomposed into predicted values and <em>individual</em> residuals <span class="math inline">\(\epsilon_i\)</span>. These are frequently called <em>errors</em>, hence the greek symbol <span class="math inline">\(\epsilon\)</span>. The standard deviation of residuals <span class="math inline">\(\sigma_\epsilon\)</span> is commonly called the <em>standard error</em>. The random pattern of the model can now be expressed as a single Normal distribution. The reason why I do not use this notation routinely, is that it only works for linear models, but not for models with other random patterns. More specifically, Generalized Linear Models @ref(generalized_linear_models) cannot be specified that way. But, for the purpose of residual analysis, it appears more intuitive.</p>
<p>The first assumption of randomness underlying the linear model simply is that the distribution follows Normal distribution. Visually, Normal distributions is characterized by:</p>
<ul>
<li>one curved peak (unimodality)</li>
<li>from which density smoothly declines towards both ends (smoothness)</li>
<li>at same rates (symmetrity)</li>
</ul>
<p>For a rough evaluation of this assumption, it suffices to extract the residuals from the model at hand and plot it as a distribution. The <code>residuals</code> command returns a vector of residual values, exactly one per observation. With the vector of residuals at hand, we can evaluate this assumption by comparing the residual distribution to its theoretical form, a perfect bell curve. The following command chain extracts the residuals from the model and pipes them into the ggplot engine to create a histogram. With <code>stat_function</code> an overlay is created with the theoretical Normal distribution, which is centered at zero. The standard error <span class="math inline">\(\sigma_\epsilon\)</span> has been estimated alongside the coefficients and is extracted using the function <code>bayr::coef</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">G_resid_age_shft &lt;-
<span class="st">  </span><span class="kw">data.frame</span>(<span class="dt">resid =</span> <span class="kw">residuals</span>(M_age_shft)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(<span class="dt">y =</span> ..density..), <span class="dt">bins =</span> <span class="dv">15</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">stat_function</span>(<span class="dt">fun =</span> dnorm, 
                <span class="dt">args =</span> <span class="kw">c</span>(<span class="dt">mean =</span> <span class="dv">0</span>, 
                         <span class="dt">sd =</span> <span class="kw">coef</span>(M_age_shft, <span class="dt">type =</span> <span class="st">&quot;disp&quot;</span>)<span class="op">$</span>center), 
                <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>)

G_resid_age_shft</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/resid_dist_1-1.png" width="672" /></p>
<p>The match of residual distribution with the theoretical distribution is not perfect, but overall this model seems to sufficiently satisfy the Normality assumption. To give a counter example, we estimate the same model using the outcome variable <code>returns</code>, which captures the number of times a participant had (desparately) returned to the homepage.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_age_rtrn &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(returns <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>age_shft, <span class="dt">data =</span> BAB1)
P_age_rtrn &lt;-<span class="st"> </span><span class="kw">posterior</span>(M_age_rtrn)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_age_rtrn &lt;-<span class="st"> </span><span class="kw">coef</span>(P_age_rtrn)
T_age_rtrn</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">parameter</th>
<th align="left">type</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="left">fixef</td>
<td align="left">Intercept</td>
<td align="right">2.563</td>
<td align="right">1.99</td>
<td align="right">3.099</td>
</tr>
<tr class="even">
<td align="left">age_shft</td>
<td align="left">fixef</td>
<td align="left">age_shft</td>
<td align="right">-0.004</td>
<td align="right">-0.02</td>
<td align="right">0.013</td>
</tr>
<tr class="odd">
<td align="left">sigma_resid</td>
<td align="left">disp</td>
<td align="left">NA</td>
<td align="right">1.875</td>
<td align="right">1.71</td>
<td align="right">2.073</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">C_age_rtrn_disp &lt;-<span class="st"> </span>
<span class="st">  </span>T_age_rtrn <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">filter</span>(type <span class="op">==</span><span class="st"> &quot;disp&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(center) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">as.numeric</span>()

G_resid_age_rtrn &lt;-
<span class="st">  </span><span class="kw">data_frame</span>(<span class="dt">resid =</span> <span class="kw">residuals</span>(M_age_rtrn)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> resid)) <span class="op">+</span><span class="st"> </span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(<span class="dt">y =</span> ..density..), <span class="dt">bins =</span> <span class="dv">10</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">stat_function</span>(<span class="dt">fun =</span> dnorm, 
                <span class="dt">args =</span> <span class="kw">c</span>(<span class="dt">mean =</span> <span class="dv">0</span>, 
                         <span class="dt">sd =</span> C_age_rtrn_disp), 
                <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">xlim</span>(<span class="op">-</span><span class="dv">5</span>, <span class="dv">5</span>)
G_resid_age_rtrn</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/resid_dist_2-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
<p>The estimation produces the usual coefficients, as well as a standard error. However, the residuals not even remotely resemble the theoretical curve. While it is unimodal, it appears rather asymmetric, with a steep rise to the left and a long tail to the right. That is a typical outcome when count measures get too close to the left boundary. How about unimodality? We have not discussed any multimodal theoretical distributions in <a href="bayesian-statistics.html#distributions">3.4.2</a>, but one has been displayed in @ref(first_program). In brief, a bimodal residual distribution can arise, when two groups exist in the data, which lay far apart. The following code illustrates the situation by simulating a simple data set with two groups, that is fed into a GMM.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Chapter_LM)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">42</span>)
D_bimod &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">bind_rows</span>(
    <span class="kw">data_frame</span>(<span class="dt">Group =</span> <span class="st">&quot;A&quot;</span>, <span class="dt">y =</span> <span class="kw">rnorm</span>(<span class="dv">50</span>, <span class="dv">4</span>, <span class="dv">1</span>)),
    <span class="kw">data_frame</span>(<span class="dt">Group =</span> <span class="st">&quot;B&quot;</span>, <span class="dt">y =</span> <span class="kw">rnorm</span>(<span class="dv">50</span>, <span class="dv">8</span>, <span class="dv">1</span>))
  )</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_bimod &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(y <span class="op">~</span><span class="st"> </span><span class="dv">1</span>, <span class="dt">data =</span> D_bimod, <span class="dt">iter =</span> <span class="dv">200</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_bimod  <span class="op">%&gt;%</span><span class="st">  </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">resid =</span> <span class="kw">residuals</span>(M_<span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> resid)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_density</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-55-1.png" width="672" /></p>
<p>These two deviations from Normal distribution have very different causes: asymmetry is caused by scales with boundaries. This is an often arising situation and it is gracefully solved by Generalized Linear Models <a href="GLM.html#GLM">7</a>. This is a family of models, where each member covers a certain type of measurement scale. In the above example, Poisson regression, applies, taking care of count measures. Mulitmodality is caused by heterogeneous groups in the data, like experimental conditions, design or type of user. For a grouping structure to cause distinguished multimodality, differences between groups have to be pronounced, in relation to the standard error. It is often the case, that these variables are controlled conditions, such as in an AB test. It is also quite likely that strong grouping structures can be thought of beforehand and be recorded. For example, in usability tests with diverse user samples, in almost comes natural to distinguiish between users who have used the design before, and those who didn’t. If the grouping variable is recorded, the solution is group comparison models <a href="linear-models.html#CGM">5.3</a>, soon to be introduced.</p>
<p>Visual assessment of symmetry and unimodality is simple and effective in many cases. But, Normal distributions are not the only to have these properties. At least logistic distributions and t distributions have these, too, with subtle different in curvature. Normal and t distributions differ in how quickly probability drops in the tails. Normal distributions drop much faster such that extreme events are practically impossible. With t-distributions, extreme values drop in probability, too, but the possibility of catastrophies (or wonders) stays substantial for a long time.</p>
<p>Provided one has a small abundance of data, <em>quantile-quantile (qq) plots</em> can be used to evaluate subtle deviations in curvature (and symmetry and unimodality). In qq plots, the observed and theoretical distributions are both flattened and put against each other. This is a powerful and concise method, but it is harder to grasp. The following code illustrates the construction of a qq-plot that compares GMM residuals of a t-distributed measure against the Normal distribution. We simulate t-distributed data, run a GMM and extract residuals, as well as the standard error <span class="math inline">\(\sigma_\epsilon\)</span>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">2</span>)
D_t &lt;-<span class="st"> </span><span class="kw">data_frame</span>(<span class="dt">y =</span> <span class="kw">rt</span>(<span class="dv">200</span>, <span class="dv">2</span>))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_t &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(y <span class="op">~</span><span class="dv">1</span>, <span class="dt">data =</span> D_t, <span class="dt">iter =</span> <span class="dv">200</span>)</code></pre></div>
<p>We obtain the following residual and theoretical distributions. It is approximately symmetric and unimodal, but the curvature seems to be a bit off.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_t &lt;-<span class="st">   </span><span class="kw">mutate</span>(D_t, <span class="dt">resid =</span> <span class="kw">residuals</span>(M_t))

C_sigma &lt;-<span class="st"> </span>rstanarm<span class="op">::</span><span class="kw">sigma</span>(M_t)

D_t <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> resid)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_histogram</span>(<span class="kw">aes</span>(<span class="dt">y =</span> ..density..)) <span class="op">+</span>
<span class="st">  </span><span class="kw">stat_function</span>(<span class="dt">fun =</span> dnorm,
                <span class="dt">args =</span> <span class="kw">c</span>(<span class="dt">mean =</span> <span class="dv">0</span>,
                         <span class="dt">sd =</span> C_sigma),
                <span class="dt">colour =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-58-1.png" width="672" /></p>
<p>The next step is where the two curves get flattened. First, we compute a sequence of quantiles with fixed steps, say 1%, 2%, … 99%%. Finally, theoretical and observed quantiles are fed into a scatterplot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_QQ &lt;-<span class="st"> </span><span class="kw">data_frame</span>(<span class="dt">step =</span> <span class="dv">0</span><span class="op">:</span><span class="dv">100</span><span class="op">/</span><span class="dv">100</span>,
           <span class="dt">quant_smpl =</span> <span class="kw">quantile</span>(D_t<span class="op">$</span>resid, step),
           <span class="dt">quant_theo =</span> <span class="kw">qnorm</span>(step, <span class="dv">0</span>, C_sigma))

D_QQ <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> quant_theo, <span class="dt">y =</span> quant_smpl)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_abline</span>(<span class="dt">slope =</span> <span class="dv">1</span>, <span class="dt">intercept =</span> <span class="dv">0</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-59-1.png" width="672" /></p>
<p>In the ideal case, they match perfectly, and the quantiles are on a straight line. Instead, we see a rotated sigmoid shape and this is typical for fat-tailed distributions such as t. The shape is symmetric with turning points at around -4 and 4 on the theoretical scale. In the middle part the relation is almost linear, however, not matching a 1-by-1. The t distribution loses probability mass rather quickly when moving from the center to the tuzrning points. here. From these points on the theoretical quantiles start lag behind. The lower and upper 1% sampled quantiles go to much more extreme values, ranging from -10 to almost 20, whereas the Normal distribution renders such events practically impossible. Generally, a rotated sigmoid shape is typical for fat tailed distributions. The problem of misusing a Normal distribution is that it dramatically underestimates extreme events. Have you ever asked yourself, why in the 1990s, the risk for a nuclear meltdown were estimated to be one in 10.000 years, in face of two such tragic events in the past 40 years? Perhaps, researchers used the Normal distribution for the risk models, under-estimating the risk of extreme events.</p>
<p>The ggplot engine provides an easy to use geometry for qqlots, which lets us further explore deviant patterns. Variables with t distribution take an inverse-sigmoid shape due to their fat tails.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_t <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">sample =</span> resid)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_qq</span>(<span class="dt">distribution =</span> qnorm) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_abline</span>(<span class="dt">intercept =</span> <span class="dv">0</span>, <span class="dt">slope =</span> <span class="dv">1</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-61-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Chapter_LM)</code></pre></div>
<p>Once mastered, the qq-plot is the swiss knife of Normality check. Next to the subtleties We can also easily discover deviations from symmetry. This is how the residuals of the returns to homepage model look like:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">  <span class="kw">data_frame</span>(<span class="dt">resid =</span> <span class="kw">residuals</span>(BrowsingAB<span class="op">$</span>M_age_rtrn)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">sample =</span> resid)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_qq</span>(<span class="dt">distribution =</span> qnorm) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_abline</span>(<span class="dt">intercept =</span> <span class="dv">0</span>, <span class="dt">slope =</span> <span class="dv">1</span>, <span class="dt">col =</span> <span class="st">&quot;red&quot;</span>)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-63-1.png" width="672" /></p>
<p>To the left, extreme values have a lower probability than predicted by the Normal distribution, but the right tail are much fatter, one again. We also see how residuals are clumped, which is characteristic for discrete (as compared to continuous) outcome measures. This is poor behaviour of the model and, generally, when a model is severely mis-spedified, neither predictions nor estimate, nor certainty statements can be fully trusted. A model that frequently fits in case of count numbers is Poisson regression, which will enter the stage in chapter @ref(poisson_regression).</p>
</div>
<div id="resid_constant_variance" class="section level4">
<h4><span class="header-section-number">5.4.4.3</span> Constant variance</h4>
<p>In @ref(resid_normality) we have assessed one assumption that underlies all linear models, namely Normal distribution of residuals. The second assumption underlying the linear model random (or residual) is that residual variance is constant throughout the whole range. In both, classic and modern notation this grounds in the there being just a single <span class="math inline">\(\sigma_\epsilon\)</span> defined. However large <span class="math inline">\(\mu_i\)</span> is, the dispersion of residuals is not supposed to change.</p>
<p>Before we dive into the matter of checking the assumption let’s do a brief reality check using common sense:</p>
<ol style="list-style-type: decimal">
<li><p>Consider people’s daily way to work. Suppose you ask a few persons you know: “What is your typical way to work and what is the longest and the shortest duration you remember?”. In statistical terms, you are asking for a center estimate and (informal) error dispersion. Is it plausible that a person with typical travel time of 5 minutes experienced the same variation as another person witha typical time of 50 minutes?</p></li>
<li><p>Consider an experiment to assess a typing training. Is it plausible that the dispersion of typing errors before the training is the same as after the training?</p></li>
</ol>
<p>In both cases, we would rather not expect constant variance and it is actually quite difficult to think of a process, where a strong change in average performance is not associated with a change in dispersion. The constant variance assumption, like the normality assumption is a usual suspect when approximating with linear models. We will come back to that down below.</p>
<p>In a similar way, we can ask: can it be taken as granted that residual variance is constant when comparing two or more groups. Would you blindly assume that two rather different designs produce the same amount spread around the average? It may be so, but one can easily think of reasons, why this might be different. We check the situation in the CGM of the BrowsingAB study. Do both design conditions have the same residual variance? Again, we extract the residuals, add them to the data set and produce a boxplot by Design condition:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">resid_Design =</span> <span class="kw">residuals</span>(M_Design)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> Design, <span class="dt">y =</span> resid_Design)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-65-1.png" width="672" /></p>
<p>Both sets of residuals are reasonably symmetric, but it appears that design B produces more widely spread residual. Something in the design causes individual performance to vary stronger from the population mean. The cause of this effect will be disclosed in @ref(differential_design_effects). (In essence, design B is rather efficient to use for younger users, whereas older users seem to have severe issues.)</p>
<p>Visual checks of constant variance for factors is straight forward using common boxplots. For continuous predictors, such as age, requires a more uncommon graphical representation known as <em>quantile plots</em>. These are not the same as qq plots, but luckily are included with ggplot.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">resid_age =</span> <span class="kw">residuals</span>(M_age)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> age, <span class="dt">y =</span> resid_age)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_quantile</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-66-1.png" width="672" /></p>
<p>The quantile plot uses a smoothing algorithm (probably not unlike LOESS) to picture the trend of quantiles (25%, 50% and 75%). Here, the quantiles run almost horizontal and parallel, which confirms constant variance. Taking this as a starting point, we can evaluate more complex models, too. The MPM on age and design, just requires to create a grouped quantile plot. This looks best using facetting, rather than separating by color:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">resid_mpm_2 =</span> <span class="kw">residuals</span>(M_mpm_<span class="dv">2</span>)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> age_shft, <span class="dt">y =</span> resid_mpm_<span class="dv">2</span>)) <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(<span class="op">~</span>Design) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_quantile</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-67-1.png" width="672" /></p>
<p>This looks rather worrying. Especially with Design A, the residuals are not constant, but increase with age. In addition, we observe that residuals are not even centered at zero across the whole range. For design A, the residual distribution moves from positive centered to negative centered, design B vice versa. That also casts doubts on the validity of the LRM on age: these contrariwise trends seem to mix into an unsuspicious even distribution. It seems that a lot more has been going on in this study, than would be captured by any of these models.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
<p>Another model type we may want to check with quantile plots is the MRM. With two continuous predictors one might be tempted to think of a 3-dimnensional quantile plot, but this is not recommended. Rather, we can use a generalization of quantile plots, where the x-axis is not mapped to the predictor, directly, but the predicted values <span class="math inline">\(\mu_i\)</span>. We assess the residual variance on the MRM model on the AUP study, where resistance to fall for the active user paradox has been predicted by geekism tendencies (gex) and need-for-cognition (ncs):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(AUP)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">AUP_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">resid_3 =</span> <span class="kw">residuals</span>(M_<span class="dv">3</span>),
         <span class="dt">mu_3 =</span> <span class="kw">predict</span>(M_<span class="dv">3</span>)<span class="op">$</span>center) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> mu_<span class="dv">3</span>, <span class="dt">y =</span> resid_<span class="dv">3</span>)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_quantile</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-70-1.png" width="672" /></p>
<p>We observe a clear trend in quantiles, with residual dispersion increasing with predicted values. Generally, plotting residuals against predicted values can be done with any model, irrespectively of the number and types of predictors. However, interpretation is more limited than when plotting them against predictors directly. In fact, interpretation boils down to the intuition we introduced at the beginning of the section, that larger outcomes typically have larger dispersion. This is almost always a compelling assumption, or even a matter of underlying physics and, once again, a linear model may or may not be a reasonable approximation. Fortunately, when we turn towards @ref(generalized_linear_models), we will find that these models take provide more reasonable defaults for the relationship between predicted values and dispersion. In contrast, residual variance per predictor allows to discover more surprising issues, such as interaction effects or heterogeneity in groups.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(AUP)</code></pre></div>
<!-- 37

What has happened here is another flavor of the endless-universe paradox. When discussing predictions, we had seen that the linear model is always compromised as it assumes an infinite range of the outcome variable. Often that is of no practical concern, as long as one stays in the safe area with predictions. The problem here arises from the residual distribution extending to infinity in both directions, too. The LR with homepage returns by age estimated number of returns of a 20-year to be `frm_coef(coef(P_age_rtrn), ~fixef == "Intercept")`, with a residual standard error of $`C_age_rtrn_disp`$. As the expected value is positive, there is no linearity paradox and we are perfectly fine.


Analysis of expected values (predictions) are necessary to discover problems with the linearity. Are the predictions we want to make in the safe range? This is essential to know for serious quantification. It is logical, that prediction analysis can only be done after the model has been applied to the data. Residual analysis is an essential part of the modelling process, too. By residual analysis we reflect on whether the Normality assumption is reasonably defensible. For variables that are counts, the distribution may not look Normal at all and impossible predictions can arise when simulating from the model. Keep in mind, that neither the linearity nor the Normality assumption are truly defensible ever, in an endless universe. 

Drawing on expected values, *residual analysis is something you can only do after estimation*. It is usually part of a process called *checking assumptions*, which somehow implies you do it beforehand, which lured many into analyzing the *distribution of the outcome* variable $y_i$ before running the model. This is a false meme, because assumptions are always checked after a certain model has been estimated. In particular, we should check three assumptions on linear models, Normal distribution, independence and homogeneity of variance, which all are codified in the classic residual formula:

$$
\epsilon_i \sim \textrm{Norm}(0, \sigma)
$$


The first assumption of linear models is obvious: the residual distribution must follow a *Normal distribution*. There is one easy and one advanced way to check that this is true. It is easiest to create a density plot from residuals and compare it to the known properties of a Normal distribution:


```bab1_check_normal
data_frame(resid = residuals(M_age)) %>% 
  ggplot(aes(x = resid)) +
  geom_density()

```

The residual distribution of `M_age` appears perfectly symmetric and has just one peak (unimodality). That is good, although the overall shape more resembles a mole hill rather than a bell curve. While it is easy to discover problems of multimodality or asymmetry in a histogram, a more advanced approach is needed, to uncover more subtle deviations. Recall what cumulative density functions (CDF) (\@ref(density-distributions)) do: for any point $x$ it gives the probability to observe a value $y_x$.

The single residual distribution assumption of linear models, as harmless as it may appear, brings forth two claims:  residuals must have the same dispersion everywhere, which is called *homogeneity  of variance* and residuals must have *independence* from any predictors. Residuals are all supposed to fall into a horizontal band of even width, like in the figure \@ref(quantile_caterpillar). Note how this figure is created by first simulating data using the approximate coefficients of model `M_age`. The independence of residuals emerges by the absence of any relation with age in the data generating code.


```quantile_caterpillar
set.seed(42)
data_frame(age = runif(200, 20, 70),
           resid = rnorm(200, 0, 46),
           Obs = dplyr::min_rank(age)) %>% 
  ggplot(aes(x = Obs, y = resid)) +
  geom_point() +
  geom_quantile()
  
```


\@ref(BAB1_resid_age_1) reveals some further issues with the models. Note that in the caterpillar plot, the x-axis is labelled with numbers, which is just an identification, but has no metric meaning. Not quite! Review the code to see that the observations were not just taken as they came, but re-arranged by age. Also, in \@ref(BAB1_resid_age_1)  a second geometry is visible, showing a so called *quantile plot*.



follow a flat line (at zero), whereas we see in the graph that the residuals tend towards negative values for older people. The same holds for the dispersion of residuals: there is exactly one $\sigma$ in the equation, hence there should not be any difference in variance between young and old.
Quantile plots resemble the boxplot, in that they approximate the 25%, 50% and 75% quantiles. Two visible trends occur in both models. First, the residuals seem to get more dispersed for higher age. Second, there is a downward trend, with the error for older people tending to be on the negative side. It seems that young and old have different residual distributions, although the classic residual term clearly demands that they come from a single distribution:



-->
</div>
</div>
<div id="how-to-plot-mpm-tbc-move-to-interaction-effects" class="section level3">
<h3><span class="header-section-number">5.4.5</span> How to plot MPM? [TBC, move to Interaction effects]</h3>
<p>Now that we have seen how we can compare on one factor, we can extend the CGM to more factors. With linear models, we can extend the basic CGM to incorporate multiple of such factors. This is called <em>multifactorial models</em> (MFM).</p>
<p>Now, we are looking at a slightly more complicated situation, where browsing is predicted by design and education level of participants at the same time.</p>
<p>First, with the <em>ggplot</em> system, we plot the new situation. Recall that</p>
<ol style="list-style-type: decimal">
<li><p>mapping variables in the data set to elemental properties in the plot, such as: x position, y position, color, shape etc.</p></li>
<li><p>selecting an appropriate geometry that carries such properties, e.g. points, bars, box plots</p></li>
</ol>
<p>Now we can do the two-factorial ANOVA in much the same way as before. We only have to add the predictor <em>Education</em> to the model formula. Then we run the MCMC estimation and get the estimates.</p>
<p>[Interaction plots with groups, IA plots with standard debs, mixed IA plots, using the AMM]</p>
</div>
<div id="empirical-versus-statistical-control" class="section level3">
<h3><span class="header-section-number">5.4.6</span> Empirical versus statistical control</h3>
<p>Fundamental researchers have a knack for the experimental method. An <em>experiment</em>, strictly, is a study where you measure the effects of variables you <em>manipulate</em>. Manipulation is, almost literally, that it is <em>in your hands</em>, who receives the treatment. The fantastic thing about manipulation is that it allows for <em>causal conclusions</em>. A <em>strictly controlled experiment</em> is when all influencing variables are either manipulated or kept constant. That is an ideal and would not even be the case if you test the same person over-and-over again (like researchers in psychophysics often do). You never jump into the same river twice.</p>
<p>Sometimes an influencing variables lends itself to be kept constant. For example in cognitive psychology experiments, environment and equipment is usually kept constant. For applied research, keeping things constant comes at a major disadvantage: it limits the possible conclusions drawn from the study. Imagine, you tested a smartphone app with participants, all students, comfortably sitting in a quiet environment. Would you dare to make conclusions on how any users perform in real life situations, say while driving a car? When keeping things constant, <em>ecological validity</em> and <em>generalizability</em> suffer.</p>
<p>In most applied design studies we need ecological validity and generalizability. If performance differs under certain conditions, you certainly want to know that. The solution is to <em>let conditions vary and record them</em> as variables, as good as possible. For example, if you were to compare two voice-controlled intelligent agent apps, you could manipulate the ambient noise level, if you are in the lab.</p>
<p>In practically all applied studies, there exist variables, which you cannot manipulate for one of the following reasons. Especially, user traits are impossible to manipulate. If someone has an extrovert character or did a lot of gaming in the past, you cannot change that. Diversity of users is a fact and people come as they are.</p>
<p>Field studies usually aim for high ecological validity. Participants are supposed to use the system in the situations they encounter. If a smartphone app is being used sitting walking, driving or on a secret place, it is crucial to observe all situations. Consider a car navigation system that is tested in a long, lonely highway situation. How much would the results tell your for performance in dense city traffic? Design researchers frequently need results that are highly representative for users and situations of use.</p>
<p>Fundamental lab researchers are afraid of individual differences, too. The reasons are different, though: all non-manipulated influencing factors add noise to the study, which makes it harder to find the effects of interest. While lab researchers do there best to keep the environment constant, they cannot keep all participant traits constant. Lab researchers have two solutions to the problem: matching and randomized control.</p>
<p>With <em>pair matching</em>, potentially relevant participant traits are recorded upfront; then participants are assigned to conditions such that groups have about the same composition. For example, one makes sure that the age distribution is about the same and both genders are equally represented. When all other influencing variables are constant between groups, the lab researcher can be sure that the effect is unambiguously caused by the manipulation. So they say and routinely record participants age, gender and nationality.</p>
<p>However, there are better alternatives: the best pair match is the person herself. Experimental studies that expose the same person to several conditions are called <em>within-subject</em>. In the special case that all participants encounter all conditions, the variable is <em>complete within-subject</em>. [A special case of within-subject design is <em>repeated measures</em>.] In the following chapter, we use mixed-effects models [LMM] to deal with within-subject designs, gracefully.</p>
<p>In design research, pair matching applies for situations, where designs are compared. In the simpler situation that a design is evaluated against set standard (e.g. 111 seconds to rent a car), it is more important to do <em>population matching</em>. The sample of participants is drawn to be <em>representative for the target population</em>. Representativeness comes in two levels: <em>coverage representation</em> is reached when all influencing properties have occurred a few times during observation. So, if your target population contains several subgroups, such as age groups, experience or people with different goals, they should all be covered to some extent. <em>Proportional representation</em> means all user and situational properties are covered <em>and</em> they have about the same proportion in teh sample as in the population.</p>
<p>You can only match what you can measure and you only measure what you expect. Human behavior in everyday life is influenced by many factors in complex ways. Although a plethora of personality inventories exists, doing them all prior to the real study is impossible. It would probably not even be effective. Never have i seen a design research study, where even the most established personality tests explain more than a few percent of variation. As another example, take the primacy effect: what you experienced first, has the strongest influence. In real life, impressions are constantly pouring on people and you will never be able to record and match that to a reasonable extent.</p>
<p>When influencing variables cannot be measured for matching or statistical control, the last resort is <em>randomized control</em>. This is a misleading term, insofar as what the researcher actually does is to <em>let go to chance</em>. Indeed, if the process of drawing participants and assigning them to manipulations is completely left to chance, then <em>in the long-term</em>, the sample will be proportional representative and all groups will have the same composition of traits. <em>Randomization</em> works well with larger samples. With small sample, it can still easily happen that one ends up with more or less biased samples or heterogeneous groups. Just by chance, more higher-educated people could have ended up in condition A of BrowsingAB.</p>
<p>Using manipulation, matching or randomization in in-the-wild research may work in some cases. In other cases it will be ineffective or impractical. The ultimate problem is the attempt to keep things constant. In applied design research the questions rarely come down to a “Is A better than B?”. If there is an age effect, you may certainly want to know it and see how the design effect compares to it. But, you can only examine what is varied and recorded. The approach of <em>statistical control</em> is to record (instead of manipulate) all variables that may influence the results and add them to the statistical model. As we will see now, the linear model puts no limits on the number of predictors. If you believe that user age may play a role for performance, just record it and add it to the model. Statistical control requires at least coverage representation of the sample.</p>
</div>
<div id="exercises-4" class="section level3">
<h3><span class="header-section-number">5.4.7</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>Rerun <code>M_3</code>, this time using the unstandardized resistance scores. Interpret the intercept.</p></li>
<li><p>The innovators behind the WWW have a long tradition in figurative use of nautical metaphors, like navigator, cybernaut, … Do people in a world-wide hypermedia system behave like animals roaming known and lesser known territory? Then we would expect performance to be dependent on abilities for spatial cognition, like the visual-spatial working memory. Another theory could draw on the fact that for most websites the written word prevails. Would we not expect people with better verbal processing capabilities to excel? Consider a study <code>MMN</code> (for Miller’s magic number, an iconic term in working memory research) that examines the influence of working memory capacities on people’s browsing performance. Two tests for WM capacity were used: the Corsi task for visual-spatial WM capacity and the Ospan task for verbal WM capacity. Then participants were given five different search tasks on five websites. As a measure of efficiency, total time on task and number of clicks were recorded. As these variables tend to have skewed residual distributions, logarithmic transformation was applied before analysis. <em>Do LRM on both WM predictors separately, then move on to an MRM.</em>.</p></li>
</ol>
</div>
</div>
<div id="interaction-effects" class="section level2">
<h2><span class="header-section-number">5.5</span> Interaction effects</h2>
<p>With the framework of MPM, we can use an arbitrary number of predictors. These can represent properties on different levels, for example, two designs proposals for a website can differ in font size, or participants differ in age. So, with MPM we gain much greater flexibility in handling data from applied design research, which allows us to examine user-design interactions (literally) more closely.</p>
<p>The catch is that if you would ask an arbitrary design researcher:</p>
<blockquote>
<p>Do you think that all users are equal? Or, could it be that one design is better for some users, but inferior for others?</p>
</blockquote>
<p>you would in most cases get the answer:</p>
<blockquote>
<p>Of course users differ in many ways and it is crucial to know your target group.</p>
</blockquote>
<p>Some will also refer to the concept of usability by the ISO 9241-11, which contains the famous four words:</p>
<blockquote>
<p>“… for a specified user …”</p>
</blockquote>
<p>The definition explicitly requires you to state for <em>for whom</em> you intended to design. It thereby implicitly acknowledges that usability of a design could be very different for another user group. In other words, statements on usability are by the ISO 9241-11 definition <em>conditional</em> on the target user group.</p>
<p>In statistical terms, conditional statements of the form:</p>
<blockquote>
<p>the effect of design changes with (some) user properties</p>
</blockquote>
<p>In regression models, conditional statements like these are represented by <em>interaction effects</em>. Interactions between user properties and designs are the most genuine in design research, and deserve a neologism: <em>differential design effects (DDM)</em>. They come with some of their siblings. <em>Saturation</em> occurs when physical (or other) boundaries are reached and the result is less than the sum. <em>Amplification</em>, a rare one, is like compound glue: it will harden only if the two components are present. The final section is a plea for interaction effects in theorizing.</p>
<div id="differential_design_effects" class="section level3">
<h3><span class="header-section-number">5.5.1</span> Users differ: differential design effects</h3>
<p>Do people differ? Yes. If you showed two web designs to a group of stakeholders, asking to choose individually. Is there any chance they would all agree? No. Is the design of universal systems easy? No. The ideal of universal design is to never put a user group at a disadvantage. If it is an ideal, than designs are likely to differ in by how much they accomplish it.</p>
<p>As to age: it is commonly held that older people tend to have lower performance than younger users. A number of factors are called responsible, such as: slower processing speed, lower working memory capacity, lower motor speed and visual problems. Is, perhaps, one of the two designs less of a burden for elderly users? We plot the observed ToT by age, this time forming groups by design.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(BrowsingAB)

G_slope_ia &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> age,
             <span class="dt">col =</span> Design,
             <span class="dt">y =</span> ToT)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_smooth</span>(<span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>, <span class="dt">se =</span> F)


G_slope_ia</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/glm_EDA_3-1.png" width="672" /></p>
<p>As we have seen, with GLM, it is possible to investigate the effect of design properties and user properties simultaneously. For example, assume that main difference between design A and B in the web browsing example is that A uses larger letters than B. Would that create the same benefit for everybody? It is not unlikely, that larger letters only matter for users that have issues with far farsightedness, which is associated with age. Maybe, there is even an adverse effect for younger users, as larger font size takes up more space on screen and more scrolling is required.</p>
<p>We recall the MPM in BrowsingAB: <code>M_mpm_2</code> showed a moderate relationship between age and ToT. The design effect was disappointing (<code>M_Design</code>): a classic statistician may have called it “significant”, but one can hardly claim practical relevance. By adding the interaction effect <code>Design:age_shft</code> to the model, we will now investigate how the age effect differs by design. We call this a <em>differential interaction effect</em>, as one of the involved</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_ia1 &lt;-<span class="st"> </span>
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span>Design <span class="op">+</span><span class="st"> </span>age_shft <span class="op">+</span><span class="st"> </span>Design<span class="op">:</span>age_shft,
                 <span class="dt">data =</span> .)

<span class="co"># T_resid &lt;- mutate(T_resid, M_ia1 = residuals(M_ia1))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_ia1 &lt;-
<span class="st">  </span><span class="kw">bind_rows</span>(
    <span class="kw">posterior</span>(M_mpm_<span class="dv">2</span>),
    <span class="kw">posterior</span>(M_ia1)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">fixef</span>()
  

T_ia1</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_ia1</td>
<td align="left">Intercept</td>
<td align="right">195.684</td>
<td align="right">176.708</td>
<td align="right">214.337</td>
</tr>
<tr class="even">
<td align="left">M_ia1</td>
<td align="left">DesignB</td>
<td align="right">-37.779</td>
<td align="right">-64.695</td>
<td align="right">-12.813</td>
</tr>
<tr class="odd">
<td align="left">M_ia1</td>
<td align="left">age_shft</td>
<td align="right">0.259</td>
<td align="right">-0.276</td>
<td align="right">0.798</td>
</tr>
<tr class="even">
<td align="left">M_ia1</td>
<td align="left">DesignB:age_shft</td>
<td align="right">0.770</td>
<td align="right">0.056</td>
<td align="right">1.557</td>
</tr>
<tr class="odd">
<td align="left">M_mpm_2</td>
<td align="left">Intercept</td>
<td align="right">184.208</td>
<td align="right">169.940</td>
<td align="right">198.789</td>
</tr>
<tr class="even">
<td align="left">M_mpm_2</td>
<td align="left">DesignB</td>
<td align="right">-14.981</td>
<td align="right">-27.804</td>
<td align="right">-2.140</td>
</tr>
<tr class="odd">
<td align="left">M_mpm_2</td>
<td align="left">age_shft</td>
<td align="right">0.648</td>
<td align="right">0.254</td>
<td align="right">1.033</td>
</tr>
</tbody>
</table>
<p>The intercept still is the performance of an average twen using reference design A. Compared to the MPM, it is less favorable, with <span class="math inline">\(195.68 [176.71, 214.34]_{CI95}\)</span> seconds time-on-task. The effect of design B improved dramatically with the DDM: a twen is now <span class="math inline">\(-37.78 [-64.7, -12.81]_{CI95}\)</span> faster with it. Is B the clear winner? It is not, because A has much lower age effect. The age parameter does no longer represent both groups, but just reference A, and it is now very small, <span class="math inline">\(0.26 [-0.28, 0.8]_{CI95}\)</span>. The final coefficient is <em>not</em> the age effect in B, but <em>the difference</em> to the reference age effect. With design B, users are getting 1.029 seconds slower per year of life. That is a lot!</p>
<p>If we can do it with covariates, like age, we can do it with factors, too. For example, does the overall improvement from design A to B depend on education level?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> ToT, <span class="dt">x =</span> Education, <span class="dt">color =</span> Design)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/BAB_ia2-1.png" width="672" /></p>
<p>Again, we compare the main-effect model to the one with interaction effects.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_mpm_<span class="dv">3</span> &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span>Design <span class="op">+</span><span class="st"> </span>Education,
                 <span class="dt">data =</span> .)

M_ia2 &lt;-<span class="st"> </span>
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span>Design <span class="op">+</span><span class="st"> </span>Education <span class="op">+</span><span class="st"> </span>Design<span class="op">:</span>Education,
                 <span class="dt">data =</span> .)

<span class="co"># T_resid &lt;- mutate(T_resid, M_ia2 = residuals(M_ia2))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_ia2 &lt;-
<span class="st">  </span><span class="kw">bind_rows</span>(
    <span class="kw">posterior</span>(M_mpm_<span class="dv">3</span>),
    <span class="kw">posterior</span>(M_ia2)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">fixef</span>() 
  

T_ia2</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">model</th>
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">M_ia2</td>
<td align="left">Intercept</td>
<td align="right">224.57</td>
<td align="right">208.53</td>
<td align="right">239.20</td>
</tr>
<tr class="even">
<td align="left">M_ia2</td>
<td align="left">DesignB</td>
<td align="right">-26.34</td>
<td align="right">-48.10</td>
<td align="right">-4.42</td>
</tr>
<tr class="odd">
<td align="left">M_ia2</td>
<td align="left">EducationMiddle</td>
<td align="right">-29.51</td>
<td align="right">-51.65</td>
<td align="right">-7.64</td>
</tr>
<tr class="even">
<td align="left">M_ia2</td>
<td align="left">EducationHigh</td>
<td align="right">-31.49</td>
<td align="right">-51.70</td>
<td align="right">-10.77</td>
</tr>
<tr class="odd">
<td align="left">M_ia2</td>
<td align="left">DesignB:EducationMiddle</td>
<td align="right">32.98</td>
<td align="right">1.61</td>
<td align="right">64.12</td>
</tr>
<tr class="even">
<td align="left">M_ia2</td>
<td align="left">DesignB:EducationHigh</td>
<td align="right">4.36</td>
<td align="right">-24.50</td>
<td align="right">32.74</td>
</tr>
<tr class="odd">
<td align="left">M_mpm_3</td>
<td align="left">Intercept</td>
<td align="right">218.83</td>
<td align="right">206.34</td>
<td align="right">231.21</td>
</tr>
<tr class="even">
<td align="left">M_mpm_3</td>
<td align="left">DesignB</td>
<td align="right">-15.11</td>
<td align="right">-26.84</td>
<td align="right">-3.27</td>
</tr>
<tr class="odd">
<td align="left">M_mpm_3</td>
<td align="left">EducationMiddle</td>
<td align="right">-13.46</td>
<td align="right">-28.80</td>
<td align="right">2.44</td>
</tr>
<tr class="even">
<td align="left">M_mpm_3</td>
<td align="left">EducationHigh</td>
<td align="right">-29.39</td>
<td align="right">-43.19</td>
<td align="right">-14.46</td>
</tr>
</tbody>
</table>
<p>The model has factors only, so there is a reference group. The intercepts in both models represent low education encountering design A. The main effect designB on low-educated users is present in both models. With the interaction term, design B looks much favorable, <span class="math inline">\(-26.34 [-48.11, -4.42]_{CI95}\)</span>. The effect of middle education has doubled, whereas it remains stable for high education.</p>
<p>That may appear strange at first, but keep in mind, that by the interaction term, the education main effects are no longer “main”: they only refer to group A, now. In the main effects model, the same education effects are assumed for both designs. Here, it is conditional on design, which brings us to the two interaction effects <code>B:Middle</code> and <code>B:High</code>. These are, once again, differences. The effect of middle education in B is <span class="math inline">\(32.98\)</span>more seconds than in A (<span class="math inline">\(-29.51\)</span>). There practically is no net effect of middle education in B. In contrast, the high education interaction effect is small, with practically makes <code>DesignB</code> a <em>main effect: it is the same in both groups</em>.</p>
<p>Count the number of parameters in both models! We have six with interaction and four without. Six is just the number of groups and, indeed, with interaction effects all group means can vary freely. That is best demonstrated by estimating a variant of the model, where six parameters represent six group means, directly. In other words, it is an AGM, without an intercept and without main effects:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_ia3 &lt;-
<span class="st">  </span>BAB1 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">0</span> <span class="op">+</span><span class="st"> </span>Design <span class="op">:</span><span class="st"> </span>Education,
                 <span class="dt">data =</span> .)
<span class="co"># T_resid &lt;- mutate(T_resid, M_ia2 = residuals(M_ia2))</span></code></pre></div>
<p>We extract the coefficients and, with a little preparation, we create an <em>interaction plot</em>. It shows the same pattern as the exploratory plot, but is fully inferential, with error bars indicate the 95% credibility interval.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_ia3 &lt;-<span class="st"> </span><span class="kw">posterior</span>(M_ia3)
T_ia3 &lt;-<span class="st"> </span><span class="kw">fixef</span>(M_ia3)
T_ia3</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">DesignA:EducationLow</td>
<td align="right">224</td>
<td align="right">208</td>
<td align="right">240</td>
</tr>
<tr class="even">
<td align="left">DesignB:EducationLow</td>
<td align="right">197</td>
<td align="right">181</td>
<td align="right">212</td>
</tr>
<tr class="odd">
<td align="left">DesignA:EducationMiddle</td>
<td align="right">194</td>
<td align="right">178</td>
<td align="right">209</td>
</tr>
<tr class="even">
<td align="left">DesignB:EducationMiddle</td>
<td align="right">200</td>
<td align="right">185</td>
<td align="right">216</td>
</tr>
<tr class="odd">
<td align="left">DesignA:EducationHigh</td>
<td align="right">192</td>
<td align="right">178</td>
<td align="right">207</td>
</tr>
<tr class="even">
<td align="left">DesignB:EducationHigh</td>
<td align="right">170</td>
<td align="right">157</td>
<td align="right">184</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_ia3 <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(fixef, <span class="dt">ToT =</span> center, lower, upper) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(fixef, <span class="kw">c</span>(<span class="st">&quot;Design&quot;</span>, <span class="st">&quot;Education&quot;</span>), <span class="st">&quot;:&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Design =</span> <span class="kw">str_replace</span>(Design, <span class="st">&quot;Design&quot;</span>, <span class="st">&quot;&quot;</span>),
         <span class="dt">Education =</span> <span class="kw">str_replace</span>(Education, <span class="st">&quot;Education&quot;</span>, <span class="st">&quot;&quot;</span>),
         <span class="dt">Education =</span> forcats<span class="op">::</span><span class="kw">fct_inorder</span>(Education)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> ToT, <span class="dt">ymin  =</span> lower, <span class="dt">ymax =</span> upper,
             <span class="dt">x =</span> Education, 
             <span class="dt">color =</span> Design, <span class="dt">group =</span> Design)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_pointrange</span>(<span class="dt">alpha =</span> .<span class="dv">5</span>) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/BAB_ia3-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(BrowsingAB)</code></pre></div>
<p>We can distinguish between <em>saturation effects</em> and <em>amplification effects</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">    <span class="kw">expand.grid</span>(<span class="dt">effect =</span> <span class="kw">c</span>(<span class="st">&quot;saturation&quot;</span>, <span class="st">&quot;amplification&quot;</span>), 
                            <span class="dt">A =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>),
                            <span class="dt">B =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)) <span class="op">%&gt;%</span>
<span class="st">        </span><span class="kw">join</span>(<span class="kw">data.frame</span>(<span class="dt">effect =</span> <span class="kw">c</span>(<span class="st">&quot;saturation&quot;</span>,<span class="st">&quot;amplification&quot;</span>),
                                        <span class="dt">beta_1 =</span> <span class="kw">c</span>(.<span class="dv">1</span>,.<span class="dv">1</span>),
                                        <span class="dt">beta_2 =</span> <span class="kw">c</span>(.<span class="dv">2</span>,.<span class="dv">2</span>),
                                        <span class="dt">beta_3 =</span> <span class="kw">c</span>(<span class="op">-</span><span class="fl">0.3</span>, <span class="fl">0.3</span>)))  <span class="op">%&gt;%</span>
<span class="st">        </span><span class="kw">mutate</span>(<span class="dt">Outcome =</span> A <span class="op">*</span><span class="st"> </span>beta_<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>B <span class="op">*</span><span class="st"> </span>beta_<span class="dv">2</span> <span class="op">+</span><span class="st"> </span>A <span class="op">*</span><span class="st"> </span>B <span class="op">*</span><span class="st"> </span>beta_<span class="dv">3</span>) <span class="op">%&gt;%</span>
<span class="st">        </span><span class="kw">mutate</span>(<span class="dt">B =</span> <span class="kw">factor</span>(B, <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;low&quot;</span>, <span class="st">&quot;high&quot;</span>)),
                     <span class="dt">A =</span> <span class="kw">factor</span>(A, <span class="dt">labels =</span> <span class="kw">c</span>(<span class="st">&quot;low&quot;</span>, <span class="st">&quot;high&quot;</span>))) <span class="op">%&gt;%</span>
<span class="st">        </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> A, <span class="dt">col =</span> B, <span class="dt">y =</span> Outcome)) <span class="op">+</span>
<span class="st">        </span><span class="kw">geom_point</span>(<span class="dt">size =</span> <span class="dv">3</span>) <span class="op">+</span>
<span class="st">        </span><span class="kw">geom_smooth</span>(<span class="kw">aes</span>(<span class="dt">group =</span> B, <span class="dt">col=</span> B), <span class="dt">method =</span> <span class="st">&quot;lm&quot;</span>) <span class="op">+</span>
<span class="st">        </span><span class="kw">facet_grid</span>(.<span class="op">~</span>effect)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/interaction_effects-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Interactions &lt;-<span class="st"> </span><span class="kw">expand.grid</span>(<span class="dt">effect =</span> <span class="kw">c</span>(<span class="st">&quot;saturation&quot;</span>, <span class="st">&quot;amplification&quot;</span>), 
                        <span class="dt">A =</span> <span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>, <span class="dt">length.out =</span> <span class="dv">11</span>),
                        <span class="dt">B =</span> <span class="kw">seq</span>(<span class="dv">0</span>,<span class="dv">1</span>, <span class="dt">length.out =</span> <span class="dv">11</span>)) <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">join</span>(<span class="kw">data.frame</span>(<span class="dt">effect =</span> <span class="kw">c</span>(<span class="st">&quot;saturation&quot;</span>,<span class="st">&quot;amplification&quot;</span>),
                                    <span class="dt">beta_1 =</span> <span class="kw">c</span>(.<span class="dv">1</span>,.<span class="dv">1</span>),
                                    <span class="dt">beta_2 =</span> <span class="kw">c</span>(.<span class="dv">2</span>,.<span class="dv">2</span>),
                                    <span class="dt">beta_3 =</span> <span class="kw">c</span>(<span class="op">-</span><span class="fl">0.3</span>, <span class="fl">0.3</span>)))  <span class="op">%&gt;%</span>
<span class="st">    </span><span class="kw">mutate</span>(<span class="dt">Outcome =</span> A <span class="op">*</span><span class="st"> </span>beta_<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>B <span class="op">*</span><span class="st"> </span>beta_<span class="dv">2</span> <span class="op">+</span><span class="st"> </span>A <span class="op">*</span><span class="st"> </span>B <span class="op">*</span><span class="st"> </span>beta_<span class="dv">3</span>)

<span class="kw">library</span>(lattice)
<span class="kw">grid.arrange</span>(
    <span class="kw">wireframe</span>(Outcome <span class="op">~</span><span class="st"> </span>A <span class="op">+</span><span class="st"> </span>B, 
                        <span class="dt">data =</span> <span class="kw">filter</span>(Interactions, effect <span class="op">==</span><span class="st"> &quot;saturation&quot;</span>),
                        <span class="dt">main =</span> <span class="st">&quot;saturation&quot;</span>),
    <span class="kw">wireframe</span>(Outcome <span class="op">~</span><span class="st"> </span>A <span class="op">+</span><span class="st"> </span>B, 
                        <span class="dt">data =</span> <span class="kw">filter</span>(Interactions, effect <span class="op">==</span><span class="st"> &quot;amplification&quot;</span>),
                        <span class="dt">main =</span> <span class="st">&quot;amplification&quot;</span>),
    <span class="dt">ncol =</span> <span class="dv">2</span>
)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/interaction_effects-2.png" width="672" /></p>
</div>
<div id="hitting-the-boundaries-of-saturation" class="section level3">
<h3><span class="header-section-number">5.5.2</span> Hitting the boundaries of saturation</h3>
<p>Most statistically trained researchers are aware of some common assumptions of linear regression, such as the normally distributed residuals and variance homogeneity. Less commonly regarded is the assumption of linearity, which arises from the basic regression formula:</p>
<p><span class="math display">\[y_i = \beta_0 + \beta_1 x_{1i} ...\]</span></p>
<p>The formula basically says, that if we increase <span class="math inline">\(x_1\)</span> (or any other influencing variable) by one unit, <span class="math inline">\(y\)</span> will increase by <span class="math inline">\(\beta_1\)</span>. It also says that <span class="math inline">\(y\)</span> is composed as a mere sum. In this section, we wil discover that these innocent assumption do not hold.</p>
<p>A major flaw with the linear model is that it presumes the regression line to increase and fall infinitely. However, <em>in an endless universe everything has boundaries</em>. The time someone needs to read a text is limited by fundamental cognitive processing speed. We may be able to reduce the inconvenience of deciphering small text, but once an optimum is reached, there is no further improvement. Boundaries of performance measures inevitably lead to non-linear relationships between predictors and outcome. Modern statistics knows several means to deal with non-linearity, some of them are introduced in later chapters of this book ([GLM, NLM]). Still, most researchers use linear models, and it often can be regarded a reasonable approximation, as long as one keeps reasonable distance to the upper and lower boundaries of the outcome.</p>
<p>Before we turn to a genuine design research case, let me explain saturation effects by an example that I hope is intuitive. It boils down to the question: do two headache pills have the double efect than one? Consider a pharmaceutical study on the effectiveness of two pain killer pills A and B. It takes place in the aftermath of a great party on a university campus. Random strolling students are asked to participate. First, they rate their experienced headache on a Likert scale ranging from “fresh like the kiss of morning dew” to “dead highway opossum”. Participants are randomly assigned to four groups, each group getting a different combination of pills: A-B, A-Placebo, B-Placebo, Placebo-Placebo. After 30 minutes, experienced headache is measured again and the difference between both measures is taken as the outcome measure, headache reduction. We inspect the position of four group means graphically:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Headache)

Pills <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> PillA, <span class="dt">col =</span> PillB, reduction)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_boxplot</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/eda_headache-1.png" width="672" /></p>
<p>When neither pill is given a slight spontaneous reduction seems to occur. Both pills alone seem to be effective in their own way, and giving them both has the most beneficial effect. However, it seems that the net effect of B is slightly weaker when administered together with A. Again, when the effect of one predictor depends on the level of another, the effect is called <em>conditional</em>.</p>
<p>Now, we will estimate and compare a set of three models, starting with the standard factorial MPM and proceeding to two models with interaction effects. The third one is an AGM with two factors, actually, although it may not seem so at first.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(reduction <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>PillA <span class="op">+</span><span class="st"> </span>PillB, <span class="dt">data =</span> Pills)
M_<span class="dv">2</span> &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(reduction <span class="op">~</span><span class="st"> </span><span class="dv">1</span> <span class="op">+</span><span class="st"> </span>PillA <span class="op">+</span><span class="st"> </span>PillB <span class="op">+</span><span class="st"> </span>PillA<span class="op">:</span>PillB, <span class="dt">data =</span> Pills)
M_<span class="dv">3</span> &lt;-<span class="st"> </span><span class="kw">stan_glm</span>(reduction <span class="op">~</span><span class="st"> </span><span class="dv">0</span> <span class="op">+</span><span class="st"> </span>PillA<span class="op">:</span>PillB, <span class="dt">data =</span> Pills)

P &lt;-<span class="st"> </span><span class="kw">bind_rows</span>(
  <span class="kw">posterior</span>(M_<span class="dv">1</span>),
  <span class="kw">posterior</span>(M_<span class="dv">2</span>),
  <span class="kw">posterior</span>(M_<span class="dv">3</span>)
)</code></pre></div>
<p>Imagine, the researcher started with the two-way MGM, estimating the fixed effects PillA and PillsB. The result is:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_fixef_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">fixef</span>(M_<span class="dv">1</span>)
T_fixef_<span class="dv">1</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">0.678</td>
<td align="right">0.384</td>
<td align="right">0.975</td>
</tr>
<tr class="even">
<td align="left">PillATRUE</td>
<td align="right">1.293</td>
<td align="right">0.959</td>
<td align="right">1.626</td>
</tr>
<tr class="odd">
<td align="left">PillBTRUE</td>
<td align="right">0.576</td>
<td align="right">0.232</td>
<td align="right">0.907</td>
</tr>
</tbody>
</table>
<p>Given these estimates, we conclude that pill A has an almost double reduction of headache compared to B. The intercept indicates that headache spontaneously diminishes at a rate of <span class="math inline">\(0.68 [0.38, 0.98]_{CI95}\)</span>. Setting the spontaneous recovery aside, what would you predict the effect to be in the group with both pills?</p>
<p>Thinking linearly you probably came up with:</p>
<p><span class="math display">\[1.87\]</span></p>
<p>Does that makes sense? Do the effects of headache pills simply add up like this? Consider a scenario, where five headache pills were compared in the same manner. If we assume linear addition of effects, some participants in the group with all pills could even experience the breathtaking sensation of <em>negative</em> headache. Certainly, the effect is not linear. But, is it in the long run? In some Hollywood movies the wounded hero consumes handful of pills before the showdown (With the exception of Leon, the Profi, where it is the scary Gary Oldman consuming some harder stuff). With two pills, how close to the boundaries are we? We can just test that by introducing an <em>interaction term</em> to the model: <code>PillaA:PillB</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_fixef_<span class="dv">2</span> &lt;-<span class="st">  </span><span class="kw">fixef</span>(M_<span class="dv">2</span>)
T_fixef_<span class="dv">2</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">0.592</td>
<td align="right">0.252</td>
<td align="right">0.940</td>
</tr>
<tr class="even">
<td align="left">PillATRUE</td>
<td align="right">1.469</td>
<td align="right">0.976</td>
<td align="right">1.940</td>
</tr>
<tr class="odd">
<td align="left">PillBTRUE</td>
<td align="right">0.746</td>
<td align="right">0.270</td>
<td align="right">1.226</td>
</tr>
<tr class="even">
<td align="left">PillATRUE:PillBTRUE</td>
<td align="right">-0.359</td>
<td align="right">-1.017</td>
<td align="right">0.315</td>
</tr>
</tbody>
</table>
<p>We first examine the main effects for both pills. Interestingly, both effects are now considerably stronger than before. Taking either pill alone is more effective than we thought from the multiple CGM. The fourth coefficient (<code>PillATRUE:PILLBTRUE</code>) is the interaction term. With the updated model we, again, predict the net headache reduction when both pills are given. This is as simple as summing up all coefficients from intercept to interaction. The result is a combined effect of both main effects, <em>reduced</em> by <span class="math inline">\(0.36\)</span>. As we would expect, the effectiveness of two pills is not their sum, but less. One can have headache to a certain degree or no headache at all. If it’s gone, any more pills have no additional effects. This is called an <em>saturation effect</em>: the more is given, the closer it gets to teh natural boundaries and the less it adds. Let me emphasize that this is not some strange (and therefore interesting) metabolic interaction between pharmaceuticals. Saturation effects must not be confused with any “real” interaction, that is theoretically interesting. Still, as we have seen, ignoring saturation effects results in severely biased estimates.</p>
<p>Back to design research! Imagine, you are testing the influence of font size on reading performance. In your experiment, you found that increasing from 8pt to 12pt cuts the required reading time by 10 seconds. According to the linear model, you had to expect the reading time to decrease by another 10 seconds, when enlarging to 16pt.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Headache)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Reading)

D_reading_time &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">data_frame</span>(<span class="dt">font_size =</span> <span class="kw">c</span>(<span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">12</span>, <span class="dv">16</span>, <span class="dv">24</span>, <span class="dv">28</span>),
           <span class="dt">observed_time =</span> <span class="kw">c</span>(<span class="ot">NA</span>, <span class="dv">40</span>, <span class="dv">30</span>, <span class="ot">NA</span>, <span class="ot">NA</span>, <span class="ot">NA</span>),
           <span class="dt">predicted_time =</span> <span class="dv">60</span> <span class="op">-</span><span class="st"> </span>font_size<span class="op">/</span><span class="dv">4</span> <span class="op">*</span><span class="st"> </span><span class="dv">10</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">as_tbl_obs</span>()

D_reading_time</code></pre></div>
<p>It should be clear by now, that these expectations have no ground: for normally sighted persons, a font size of 12 is easy enough to decipher and another increase will not have the same effect. Taking this further, one would even arrive at absurdly short or impossible negative reading times. At the opposite, a font size of four point may just render unreadable on a computer screen. Instead of a moderate increase by 10 seconds, participants may have to decipher and guess the individual words, which will take much longer.</p>
<p>Researching the effect of font sizes between 8pt and 12pt font size probably keeps the right distance, with approximate linearity within that range. But what happens if you when you bring a second manipulation into the game, that has a functionally similar effect? A likely outcome is that the fundamental assumption of <em>predictors sum up</em> no longer holds, but <em>saturation</em> occurs.</p>
<p>Let’s turn to a fictional, yet realistic problem in design research. Design of systems is a matter of compromises. A common conflict of interests is between the aesthetic appearance and the ergonomic properties. Consider the typesetting on web pages. Many commercial websites are equally concerned about the ease of comprehending information and positive emotional response. From an ergonomic point of view, the typesetting of longer text simply requires you to choose the best screen-readable font, find an optimal font size and maximize contrast. If you were now to suggest typesetting a website in black Arial on white background, you are in for trouble with your graphic designer or, much worse, the manager responsible for corporate impression management. In any case, someone will insist on a fancy serif font (which renders rather poorly on low resolution devices) in an understating blueish-grey tone. For creating a relaxed reading experience, the only option left is to increase the font size. This option is limited by another compromise, though, as too large letters requires excessive scrolling.</p>
<p>The question arises: can one sufficiently compensate lack of contrast by setting the text in the maximum reasonable font size 12pt, as compared to the more typical 10pt? In the fictional study Reading, this is examined in a 2x2 between-subject design: the same page of text is presented in four versions, with either 10pt or 12pt, and grey versus black font color. Performance is here measured as time-on-task of reading the full page.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_<span class="dv">1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">col =</span> font_color,
             <span class="dt">x =</span> font_size,
             <span class="dt">y =</span> ToT)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/reading_expl_1-1.png" width="672" /></p>
<p>We see immediately, that both design choices have a an impact: more contrast, as well as larger letters lead to improved reading performance. But, do they add up? Or do both factors behave like headache pills, where more is more, but less than the sum. Clearly, the 12pt-black group could read fastest on average. So, neither with large font, nor with optimal contrast alone has the design reached maximum performance, i.e. saturation. Still, there could be an interaction effect, that gradually reduces the positive effect of large font in a high-contrast design. We run two regression model, one with both main effects and one that adds an interaction term. We extract the coefficients from both models and view them side-by-side:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_<span class="dv">1</span> &lt;-
<span class="st">  </span>D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span>font_size <span class="op">+</span><span class="st"> </span>font_color,
           <span class="dt">data =</span> .)

M_<span class="dv">2</span> &lt;-
<span class="st">  </span>D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span>font_size <span class="op">+</span><span class="st"> </span>font_color <span class="op">+</span><span class="st"> </span>font_size <span class="op">:</span><span class="st"> </span>font_color,
           <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_read_fixef &lt;-
<span class="st">  </span><span class="kw">right_join</span>(<span class="kw">select</span>(<span class="kw">fixef</span>(M_<span class="dv">1</span>), fixef, <span class="dt">M_1 =</span> center),
             <span class="kw">select</span>(<span class="kw">fixef</span>(M_<span class="dv">2</span>), fixef, <span class="dt">M_2 =</span> center),
             <span class="dt">by =</span> <span class="st">&quot;fixef&quot;</span>)

T_read_fixef</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">M_1</th>
<th align="right">M_2</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">59.79</td>
<td align="right">61.17</td>
</tr>
<tr class="even">
<td align="left">font_size12pt</td>
<td align="right">-9.91</td>
<td align="right">-12.45</td>
</tr>
<tr class="odd">
<td align="left">font_colorblack</td>
<td align="right">-8.23</td>
<td align="right">-10.78</td>
</tr>
<tr class="even">
<td align="left">font_size12pt:font_colorblack</td>
<td align="right">NA</td>
<td align="right">5.22</td>
</tr>
</tbody>
</table>
<p>The estimates confirm, that both manipulations have a considerable effect. And, there is an interaction effect as well, correcting the additive effect of font color and size. The combined effect of high contrast and large font is therefore</p>
<p><span class="math display">\[
\mu_{12pt, black} =
61.172 + -12.45 + 
-10.783 + 5.222 = 
43.161
\]</span></p>
<p>In the research scenario, that was not the question, strictly, as we were primarily interested in comparing the effects of font size and contrast. Also, if we see the credibility interval of the interaction effect it is not highly certain (<span class="math inline">\(5.22 [-2.25, 12.57]_{CI95}\)</span>)) Still, including the interaction term is the right choice, for two reasons: first, both manipulations influence the same cognitive processing, as they both improve visual clarity, with the effect of better visual letter recognition. From a theoretical perspective, we would thus expect saturation. This is simply the application of prior knowledge and in a perfect world one would use a prior distribution for the interaction term, creating a more certain estimate. That being said, the data set is synthetic, and the simulation definitely included the interaction effect. Second, in Table [XY], all other coefficients change considerably with introduction of the interaction effect. Especially, the effects of the two manipulations get considerably under-estimated.</p>
<p>Why are the main effects under-estimated, when not including the interaction term? The pure main-effects model has three parameters. This allows it to represent the same number of independent group means. Formally, the number of groups in the study is four. However, the three-parameter model assumes that the fourth group (black, 12pt) can sufficiently be specified by the existing three parameters. If saturation occurs, the group of participants in the 12pt group is not homogeneous: in the grey group, they experience a stronger improvement than in the black group. The three parameter model is forced to make the best out of situation and adjusts the net effect of font size to be slightly lower than it actually is. The same occurs for the font color effect.</p>
<p>Interaction effects are notoriously neglected in research, and they are hard to grasp for audience with or without a classic statistics education. It is therefore highly recommended to illustrate interaction effects using interaction plots. To begin with, an interaction plot for the 2x2 design contains the four estimated group means. These can be computed from the linear model coefficients, but there is an alternative way: we modify the model, such that it represents the four group means, directly. The re-parametrized model has no intercept (if we want the group means directly, we need no reference group), and no main effects. The model contains just the raw interaction effect, which results in an estimation of the four group means:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_<span class="dv">3</span> &lt;-
<span class="st">  </span>D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(ToT <span class="op">~</span><span class="st"> </span><span class="dv">0</span> <span class="op">+</span><span class="st"> </span>font_size <span class="op">:</span><span class="st"> </span>font_color,
           <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">fixef</span>(M_<span class="dv">3</span>)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">font_size10pt:font_colorgray</td>
<td align="right">60.9</td>
<td align="right">56.7</td>
<td align="right">64.9</td>
</tr>
<tr class="even">
<td align="left">font_size12pt:font_colorgray</td>
<td align="right">48.2</td>
<td align="right">44.2</td>
<td align="right">52.2</td>
</tr>
<tr class="odd">
<td align="left">font_size10pt:font_colorblack</td>
<td align="right">49.8</td>
<td align="right">45.9</td>
<td align="right">53.7</td>
</tr>
<tr class="even">
<td align="left">font_size12pt:font_colorblack</td>
<td align="right">42.8</td>
<td align="right">38.8</td>
<td align="right">46.5</td>
</tr>
</tbody>
</table>
<p>With some basic data transformation on the coefficient table, we create a data frame that encodes the two factors separately. Note how <code>separate</code> is used to split the coefficient names into group identifiers. Using <code>mutate</code> and <code>str_replace</code>, the group labels are stripped the factor names. The resulting coefficient table serves as input to ggplot, creating an interaction plot with overlayed credibility intervals, using <code>geom_errorbar</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_2x2_mu &lt;-
<span class="st">  </span><span class="kw">fixef</span>(M_<span class="dv">3</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">separate</span>(fixef, <span class="kw">c</span>(<span class="st">&quot;font_size&quot;</span>, <span class="st">&quot;font_color&quot;</span>), <span class="dt">sep =</span> <span class="st">&quot;:&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">font_size =</span> <span class="kw">str_replace</span>(font_size, <span class="st">&quot;font_size&quot;</span>, <span class="st">&quot;&quot;</span>),
         <span class="dt">font_color =</span> <span class="kw">str_replace</span>(font_color, <span class="st">&quot;font_color&quot;</span>, <span class="st">&quot;&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">as.data.frame</span>()

G_interaction &lt;-
<span class="st">  </span>T_2x2_mu <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> font_color, 
             <span class="dt">color =</span> font_size, <span class="dt">shape =</span> font_size,
             <span class="dt">y =</span> center,
             <span class="dt">ymin =</span> lower,
             <span class="dt">ymax =</span> upper)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> font_size)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_errorbar</span>(<span class="dt">width =</span> .<span class="dv">1</span>)

G_interaction</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/reading-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Reading)</code></pre></div>
<p>From Figure XY we can easily spot the two main effects, and how they go together. The researcher would conclude that with the desired gray font, increasing font size partly compensates for the lack of contrast. At the same time, we see that some saturation occurs, but still, from a purely ergonomic perspective, large font and high contrast is the preferred design.</p>
<p>We have seen in the Headache example that interaction effects occur as non-linearity. The more a participant approaches the natural boundary of zero headache, the less benefit is created by additional effort. This we call <em>saturation</em>. Saturation is likely to occur when multiple factors influence the same cognitive or physical system or functioning. In quantitative comparative design studies, we gain a more detailed picture on the co-impact of design interventions and can come to more sophisticated decisions.</p>
<p>In the Reading case, overall utility is a compound of ergonomic quality and aesthetic appeal. It was assumed that a gray-on-white color scheme is more appealing. The researcher would choose the gray-12pt design: higher contrast would increase ergonomic value, but too much at the expense of appeal. Of course, in a perfect world, one would add emotional appeal as a second measure to the study.</p>
<p>If we don’t account for saturation by introducing interaction terms, we are prone to underestimate the net effect of any of these measures, and may falsely conclude that a certain measure is ineffective. Consider a large scale study, that assesses the simultaneous impact of many demographic variables on how willing customers are to take certain energy saving actions in their homes. It is very likely that subsets of variables are associated with similar cognitive processes. For example, certain action requires little effort (such as switching off lights in unoccupied rooms), whereas others are time-consuming (drying the laundry outside). At the same time, customers may vary in the overall eagerness (motivation). For high effort actions the impact of motivation level probably makes more of a difference as when effort is low. Not including the interaction effect would result in the false conclusion that suggesting high effort actions is rather ineffective.</p>
</div>
<div id="more-than-the-sum-amplification" class="section level3">
<h3><span class="header-section-number">5.5.3</span> More than the sum: amplification</h3>
<p>Saturation effect occur, when multiple impact factors act on the same system and work in the same direction. When reaching the boundaries, the change per unit diminishes. These impact factors can be similar (headache pills) or unsimilar, like font size and contrast. Still, they are to some extent exchangeable. We can compensate lack of contrast with larger font size.</p>
<p><em>Amplification</em> interaction effects are the opposite: They occur, when two (or more) factors impact different cognitive processes in a processing chain. Conceiving good examples for amplification effects is far more challenging as compared to saturation effects. Probably this is because saturation is a rather trivial phenomenon, whereas amplification involves some non-trivial orchestration of cognitive or physiological subprocesses. Here, a fictional case on technology acceptance will serve to illustrate amplification effects. Imagine a start-up company that seeks funding for a novel augmented reality game, where groups of gamers compete for territory. For their fund raising endeavor they need to know their market potential, i.e. which fraction of the population is potentially interested. The entrepreneurs have two hypotheses they want to verify:</p>
<ol style="list-style-type: decimal">
<li><p>Only technophile persons will dare to play the game, because it requires some top-notch equipment.</p></li>
<li><p>The game is strongly cooperative and therefore more attractive for people with a strong social motif.</p></li>
</ol>
<p>In their study they asked a larger set of participants to rate their technophily and sociophily. Then they were given a description of the planned game and were asked how much they intend to participate in the game.</p>
<p>While the example primarily serves to introduce amplification effects, it is also an opportunity to get familiar with interaction effect between metric predictors. While this is not very different to interaction effects on groups, there are a few peculiarities, one being that we cannot straight-forwardly make an exploratory plot. For factors we have used box plots, but these do not apply for metric variables. In fact, it is very difficult to come up with a good graphical representation. One might think of 3D wire-frame plots, but these transfer poorly to the 2D medium of these pages. Another option is to create a scatter-plot with the predictors on axis and encode the outcome variable by shades or size of dots. These options may suffice to see any present main effects, but are too coarse to discover subtle non-linearity. The closest we can get to a good illustration is create groups and continue as usual. Note that turning metric predictors into factors is just a hack to create exploratory graphs. By no means do I intend to corroborate the use of group-mean models on metric data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(AR_game)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">Sociophile =</span> forcats<span class="op">::</span><span class="kw">fct_rev</span>(<span class="kw">ifelse</span>(sociophile <span class="op">&gt;</span><span class="st"> </span><span class="kw">median</span>(sociophile), <span class="st">&quot;high&quot;</span>, <span class="st">&quot;low&quot;</span>)),
         <span class="dt">Technophile =</span> forcats<span class="op">::</span><span class="kw">fct_rev</span>(<span class="kw">ifelse</span>(technophile <span class="op">&gt;</span><span class="st"> </span><span class="kw">median</span>(technophile), <span class="st">&quot;high&quot;</span>, <span class="st">&quot;low&quot;</span>))) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">y =</span> intention, <span class="dt">x =</span> Technophile, <span class="dt">col =</span> Sociophile)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">ylim</span>(<span class="dv">0</span>, <span class="fl">0.5</span>)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-89-1.png" width="672" /></p>
<p>From the boxplot it seems that both predictors have a positive effect on intention to play. However, it remains vague if there is an interaction effect. In absence of a good visualization, we have to rely fully on the numerical estimates of a linear regression with interaction effect.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_<span class="dv">1</span> &lt;-
<span class="st">  </span>D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(intention <span class="op">~</span><span class="st"> </span>sociophile <span class="op">*</span><span class="st"> </span>technophile,
           <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">fixef</span>(M_<span class="dv">1</span>)
T_<span class="dv">1</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">0.273</td>
<td align="right">0.259</td>
<td align="right">0.288</td>
</tr>
<tr class="even">
<td align="left">sociophile</td>
<td align="right">0.113</td>
<td align="right">0.075</td>
<td align="right">0.153</td>
</tr>
<tr class="odd">
<td align="left">technophile</td>
<td align="right">0.183</td>
<td align="right">0.152</td>
<td align="right">0.212</td>
</tr>
<tr class="even">
<td align="left">sociophile:technophile</td>
<td align="right">0.165</td>
<td align="right">0.082</td>
<td align="right">0.246</td>
</tr>
</tbody>
</table>
<p>The regression model confirms that sociophilia and technophilia both have a moderate effect on intention. Both main effects are clearly in the positive range. Yet, when both increase, the intention increases overlinearly. The sociophile-technophile personality is the primary target group.</p>
<p>While plotting the relationship between three metric variables is difficult, there are alternative ways to illustrate the effect. For example, we could ask: how does intention change by .1 unit sociophilia for two imaginary participants with extreme positions on technophilia (e.g., .2 and .8). We could calculate these values arithmetically using the model formula and the center estimates. The better and genuinely Bayesian way of doing it is sampling from the <em>posterior predictive distribution</em> (PPD). This distribution is generated during parameter estimation. While the posterior distribution (PD) represents the predictors, the PPD is linked to the outcome variable. More specifically, the PPD is the models best guess of the true value <span class="math inline">\(\mu\)</span>, separated from the random component. Once the posterior has been estimated, we can draw from it with any values of interest. As these can be combinations of values that have never been observed, we can truly speak of prediction. Regression engines usually provide easy means to simulate from a PD and generate predictions. In the following example, we simulate some equidistant steps of sociophilia for three participants with technophilia scores from .1 to .9.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_<span class="dv">2</span> &lt;-<span class="st"> </span>
<span class="st">  </span>mascutils<span class="op">::</span><span class="kw">expand_grid</span>(<span class="dt">technophile =</span> <span class="kw">seq</span>(.<span class="dv">1</span>, .<span class="dv">9</span>, <span class="dt">by =</span> .<span class="dv">1</span>),
                              <span class="dt">sociophile =</span> <span class="kw">seq</span>(.<span class="dv">3</span>, .<span class="dv">6</span>, <span class="dt">by =</span> .<span class="dv">1</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(technophile)

T_1_pred &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">post_pred</span>(M_<span class="dv">1</span>, <span class="dt">newdata =</span> D_<span class="dv">2</span>, <span class="dt">thin =</span><span class="dv">2</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">predict</span>()

D_<span class="dv">2</span> &lt;-<span class="st"> </span>
<span class="st">  </span>D_<span class="dv">2</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">intention =</span> T_1_pred<span class="op">$</span>center)

D_<span class="dv">2</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">technophile =</span> <span class="kw">as.factor</span>(technophile)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> sociophile, <span class="dt">col =</span> technophile, <span class="dt">y =</span> intention)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_point</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">group =</span> technophile))</code></pre></div>
<p>The effect is not stunning, but visible. The lines diverge, which means they have different slopes. With high technophilia, every (tenth) unit of sociophilia has a stronger effect on intention to play.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(AR_game)</code></pre></div>
<p>Amplification effects are like two-component glue. When using only one of the components you just get a smear. Putting both togeher gives a strong hold. There also is a parallel in Boolean algebra. Recall, the Boolean OR operator returns <code>TRUE</code> when one of the operands is <code>TRUE</code>, whereas AND requires both operands to be <code>TRUE</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_bool_interaction &lt;-
<span class="kw">data_frame</span>(<span class="dt">A =</span> <span class="kw">c</span>(F, F, T, T),
           <span class="dt">B =</span> <span class="kw">c</span>(F, T, F, T)) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">as_data_frame</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="st">&quot;A OR B&quot;</span> =<span class="st"> </span>A <span class="op">|</span><span class="st"> </span>B) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="st">&quot;A AND B&quot;</span> =<span class="st"> </span>A <span class="op">&amp;</span><span class="st"> </span>B)
 
<span class="kw">kable</span>(T_bool_interaction)</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">A</th>
<th align="left">B</th>
<th align="left">A OR B</th>
<th align="left">A AND B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left">FALSE</td>
<td align="left">TRUE</td>
<td align="left">TRUE</td>
<td align="left">FALSE</td>
</tr>
<tr class="odd">
<td align="left">TRUE</td>
<td align="left">FALSE</td>
<td align="left">TRUE</td>
<td align="left">FALSE</td>
</tr>
<tr class="even">
<td align="left">TRUE</td>
<td align="left">TRUE</td>
<td align="left">TRUE</td>
<td align="left">TRUE</td>
</tr>
</tbody>
</table>
<p>The Boolean OR is an extreme case of saturation. Once one of the factors is present, the result is “positive” and introducing the other one has absolutely no additional effect. Another basic Boolean operation is <span class="math inline">\(A AND B\)</span> with quite the opposite effect: any of the two factors only has an effect, if the other is present, too. Clearly, this is a conditional effect. Rarely will we encounter non-trivial cases where the results are so crisp as in the Boolean world.</p>
</div>
<div id="theoretically-interesting-interaction-effects-edit" class="section level3">
<h3><span class="header-section-number">5.5.4</span> Theoretically interesting interaction effects [EDIT]</h3>
<p>Explaining or predicting complex behavior with psychological theory is one corner stone of design research. Unfortunately, it is not that easy. While design is definitely multifactorial, with a variety of cognitive processes, individual diferences and behavioural strategies, few psychological theories cover more than three associations between external or individual conditions and behavior. The design researcher is often forced to enter a rather narrow perspective, or knit a patchwork model from multiple theories. Such a model can either be loose, making few assumptions on how the impact factors interact which others. A more tightened model frames multiple impact factors into a conditional network, where impact of one factor can depend on the overall configuration. A classic study will now serve to show how interaction effects and theoretical reasoning go together.</p>
<p>Vigilance is the ability to endure in attention for rarely occurring events. Think of truck drivers on lonely night rides, where most of the time they spend keeping the truck on a straight 80km/h course. Only every now and then is the driver required to react to an event like braking lights flaring up ahead. Vigilance tasks are among the hardest thing to ask from a human operator, yet, they are safety relevant in a number of domains. Keeping up vigilance most people perceive as tiring, and vigilance deteriorates with tiredness.</p>
<p>Several studies have shown that reaction time at simple tasks increases when people are tired. The disturbing effect of noise has been documented as well. A study by Corcoran (1961) examined the simultaneous influence of sleep deprivation and noise on a rather simple reaction task. They ask:</p>
<blockquote>
<p>will the effects of noise summate with those of loss of sleep to induce an even greater performance decrement or will noise subtract from the performance decrement caused by loss of sleep?</p>
</blockquote>
<p>The central argument is that sleep deprivation deteriorates a central nervous arousal system. In consequence, sleep deprived persons cannot maintain the necessary level of tension that goes with the task. Noise is a source of irritation and therefore usually reduces performance. At the same time, noise may have an arousing effect, which may compensate for the loss of arousal due to sleep deprivation. To re-iterate on the headache pills analogy, noise could be the antidote for sleepiness.</p>
<p>The Sleep case study is a simplified simulation of Corcoran’s results. Participants were divided into 2x2 groups (quiet/noisy, rested/deprived) and has to react to five signal lamps in a succession of trials. In the original study, as performance measure gaps were counted, which is the number of delayed reactions (<span class="math inline">\(&gt;1500ms\)</span>).</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Sleep)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">G_expl &lt;-
<span class="st">  </span>D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> Environment,
             <span class="dt">color =</span> Sleep,
             <span class="dt">y =</span> gaps)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()
G_expl</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/Sleep_expl-1.png" width="672" /></p>
<p>Using a 2x2 model including an interaction effect, we examine the conditional association between noise and sleepiness. The <code>*</code> operator in the model formula is an abbreviation for the fully factorial term <code>Environment + Sleep + Environment:Sleep</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_<span class="dv">1</span> &lt;-<span class="st"> </span>
<span class="st">  </span>D_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">stan_glm</span>(gaps <span class="op">~</span><span class="st"> </span>Environment <span class="op">*</span><span class="st"> </span>Sleep, <span class="dt">data =</span> .)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_fixef &lt;-<span class="st">  </span><span class="kw">fixef</span>(M_<span class="dv">1</span>)
T_fixef</code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">99.01</td>
<td align="right">65.1</td>
<td align="right">132.8</td>
</tr>
<tr class="even">
<td align="left">EnvironmentNoisy</td>
<td align="right">-0.16</td>
<td align="right">-51.3</td>
<td align="right">51.3</td>
</tr>
<tr class="odd">
<td align="left">SleepSleepy</td>
<td align="right">160.31</td>
<td align="right">113.5</td>
<td align="right">209.5</td>
</tr>
<tr class="even">
<td align="left">EnvironmentNoisy:SleepSleepy</td>
<td align="right">-98.91</td>
<td align="right">-168.6</td>
<td align="right">-29.6</td>
</tr>
</tbody>
</table>
<p>Recall, that treatment contrasts were used, where all effects are given relative to the reference group quiet-rested, (intercept). The results confirm the deteriorating effect of sleepiness, although its exact impact is blurred by pronounced uncertainty <span class="math inline">\(160.32 [113.49, 209.55]_{CI95}\)</span>. Somewhat surprisingly, noise did not affect well-rested persons by much <span class="math inline">\(-0.16 [-51.33, 51.31]_{CI95}\)</span>. Note however, that we cannot conclude a null effect, as the credibility limits are wide. Maybe the lack of a clear effect is because steady white noise was used, not a disturbing tumult. The irritating effect of noise may therefor be minimal. As suggested by Corcoran, the effect of sleepiness on performance is partly reduced in a noisy environment <span class="math inline">\(-98.91 [-168.62, -29.62]_{CI95}\)</span>. This suggests that the arousal system is involved in the deteriorating effect of sleep deprivation, which has interesting consequences for the design of vigilance tasks in the real world.</p>
<p>The finding also relates to the well known Yerkes-Dodson law in ergonomic science. The law states that human performance at cognitive tasks is influenced by arousal. The influence is not linear, but better approximated with a curve as shown in Figure XY. Performance is highest at a moderate level of arousal. If we assume that sleepy participants in Corcona’s study showed low performance due to under-arousal, the noise perhaps has increased the arousal level, resulting in better performance. If we except that noise has an arousing effect, the null effect of noise on rested participants stands in opposition to the Yerkes-Dodson law: if rested participants were on an optimal arousal level, additional arousal would usually have a negative effect on performance. There is the slight possibility, that Corcona has hit a sweet spot: if we assume that calm/rested participants were still below an optimal arousal level, noise could have pushed them right to the opposite point.</p>
<p>Central to the Yerkes-Dodson law is that arousal is a gradually increasing property, but the current experiment only features two levels. A straight line is the only way to unambiguously connect two group means; examining any curved relationships is impossible. We could think of varying noise levels over a wider range for better tracing the non-linear relationship between arousal and performance. The next section introduces polynomial regression for approximating non-linear associations between metric variables.</p>
<p><img src="Classic_linear_models_files/figure-html/Yerkes_Dodson_1-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Sleep)</code></pre></div>
</div>
<div id="exercises-5" class="section level3">
<h3><span class="header-section-number">5.5.5</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In case IPump (data set D_agg), two infusion pumps haven been tested against each other (L = legacy, N = novel). Nurses from two professional groups (intensive and general care) completed a sequence of tasks with both devices. In order to account for learning effects, this procedure was repeated in three sessions. Three performance measures were taken: time-on-task, deviations from the optimal path and self-reported workload. Analyze the results using the models that have been introduced so far. Start with basic CGM and LRM, then use these as building blocks for more complex models. At least for the more basic models, always start by an exploratory plot. Then build and run the model. Extract the coefficients table and interpret magnitude and certainty.</p></li>
<li><p>For the basic models of the previous exercise, extract and plot the residual distribution. Compare the residual distribution by groups.</p></li>
<li><p>For the more complex models, extract the predicted values and residuals and plot them. Is their an association between the two?</p></li>
</ol>
</div>
</div>
<div id="polynomial_regression" class="section level2">
<h2><span class="header-section-number">5.6</span> Doing the rollercoaster: polynomial regression</h2>
<p>Robots build our cars and sometimes drive them. They mow the lawn and may soon also deliver parcels to far-off regions. Prophecy is that robots will also enter social domains, such as accompany children and care for our seniors. One can assume that in social settings emotional acceptance plays a significant role for technology adoption. Next to our voices, our faces and mimic expressions are the main source of interpersonal messaging. Since the dawn of the very idea of robots, anthropomorphic designs have been dominant. Researchers and designers all around the globe are currently pushing the limits of human-likeness of robots. One could assume that emotional response improves with every small step towards perfection. Unfortunately, this is not so. [Mori] discovered a bizarre non-linearity in human response: people respond more positive to improvements in human-likeness, but only at the lower end. A feline robot design with recognizable but stylized facial features will always beat a faceless robot with a strong mechanical appeal. Designs on the high end, that are very human-like, but not exactly, face a sudden drop in emotional response, which is called the <em>uncanny valley</em>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">G_uncanny_illu &lt;-
<span class="st">  </span><span class="kw">data_frame</span>(<span class="dt">hl =</span> <span class="kw">seq</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>, <span class="dt">length.out =</span> <span class="dv">100</span>),
             <span class="dt">likeability =</span> <span class="op">-</span>.<span class="dv">5</span> <span class="op">*</span><span class="st"> </span>hl <span class="op">+</span><span class="st"> </span>.<span class="dv">6</span> <span class="op">*</span><span class="st"> </span>hl<span class="op">^</span><span class="dv">3</span> <span class="op">+</span><span class="st"> </span>.<span class="dv">2</span> <span class="op">*</span><span class="st"> </span>hl<span class="op">^</span><span class="dv">4</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">human_likeness =</span> (hl <span class="op">+</span><span class="st"> </span><span class="dv">1</span>)<span class="op">/</span><span class="dv">2</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> human_likeness, <span class="dt">y =</span> likeability)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>()

G_uncanny_illu</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/uncanny_valley-1.png" width="672" /></p>
<p>[Mathur et al.] study aimed at rendering the association between human-likeness and liking at full range. They collected 60 pictures of robots and attached a score ranging from mechanical to human appearance. Then they let more than 200 participants rate the faces on how much they liked them. Finally, they created an average score of likability per robot picture and examined the association with human likeness using a statistical model. Owing to the curved shape of the uncanny valley, linear regression is not applicable to the problem. Instead, Mathur et al. applied a third degree polynomial term.</p>
<p>A polynomial function of degree <span class="math inline">\(k\)</span> has the form:</p>
<p><span class="math display">\[y_i = \beta_0 x_i^0 + \beta_1 x_i^1 + ... + \beta_{k}  x_i^{k}\]</span></p>
<p>In fact, you are already familiar with two polynomial models. The zero degree polynomial is the grand mean model. This follows from <span class="math inline">\(x_i^0 = 1\)</span>, which makes <span class="math inline">\(\beta_0\)</span> a constant, the intercept. Also, a first degree polynomial is just the linear model. By adding higher degrees we can introduce more complex curvature to the association.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">D_poly &lt;-
<span class="st">  </span><span class="kw">data_frame</span>(<span class="dt">x =</span> <span class="kw">seq</span>(<span class="op">-</span><span class="dv">2</span>, <span class="dv">3</span>, <span class="dt">by =</span> .<span class="dv">1</span>),
             <span class="dt">degree_0 =</span> <span class="dv">2</span>,
             <span class="dt">degree_1 =</span> degree_<span class="dv">0</span> <span class="op">+</span><span class="st"> </span><span class="dv">3</span> <span class="op">*</span><span class="st"> </span>x,
             <span class="dt">degree_2 =</span> <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>(degree_<span class="dv">1</span> <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="op">*</span><span class="st"> </span>x<span class="op">^</span><span class="dv">2</span>),
             <span class="dt">degree_3 =</span> <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>(degree_<span class="dv">2</span> <span class="op">+</span><span class="st"> </span><span class="op">-</span><span class="dv">1</span> <span class="op">*</span><span class="st"> </span>x<span class="op">^</span><span class="dv">3</span>),
             <span class="dt">degree_4 =</span> <span class="fl">0.5</span> <span class="op">*</span><span class="st"> </span>(degree_<span class="dv">3</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.2</span> <span class="op">*</span><span class="st"> </span>x<span class="op">^</span><span class="dv">4</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">gather</span>(polynomial, y, degree_<span class="dv">0</span><span class="op">:</span>degree_<span class="dv">4</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">arrange</span>(polynomial, y, x)
D_poly <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(x, y)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_line</span>() <span class="op">+</span>
<span class="st">  </span><span class="kw">facet_grid</span>(<span class="op">~</span>polynomial)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-97-1.png" width="672" /></p>
<p>Mathur et al. argue that the Uncanny Valley curve possesses two stationary points, where the slope is zero. One is a local minimum and represents the deepest point in the valley. The second is a local maximum and marks the shoulder left of the valley. Such a curvature can be approximated with a polynomial of (at least) third degree, which has a constant term <span class="math inline">\(\beta_0\)</span>, a linear slope <span class="math inline">\(x\beta_1\)</span>, quadratic component <span class="math inline">\(x^2\beta_2\)</span> and a cubic component <span class="math inline">\(x^3\beta_3\)</span>.</p>
<p>While R provides high-level methods to deal with polynomial regression, it is instructive to build the regression manually. The first step is to add variables to the data frame, which are the exponentiated predictors (<span class="math inline">\(x_k = x^k\)</span>). These variables are then straight-forwardly added to the model term, as if they were independent predictors. For better clarity, we rename the Intercept to be <span class="math inline">\(x_0\)</span>, before summarizing the fixed effects.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">attach</span>(Uncanny)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">M_poly &lt;-
<span class="st">  </span>UV_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">huMech_0 =</span> <span class="dv">1</span>,
         <span class="dt">huMech_1 =</span> huMech,
         <span class="dt">huMech_2 =</span> huMech<span class="op">^</span><span class="dv">2</span>,
         <span class="dt">huMech_3 =</span> huMech<span class="op">^</span><span class="dv">3</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">stan_glm</span>(avg_like <span class="op">~</span><span class="st">  </span><span class="op">+</span><span class="st"> </span>huMech_<span class="dv">1</span> <span class="op">+</span><span class="st"> </span>huMech_<span class="dv">2</span> <span class="op">+</span><span class="st"> </span>huMech_<span class="dv">3</span>,
           <span class="dt">data =</span> ., <span class="dt">iter =</span> <span class="dv">400</span>)
  <span class="co"># stan_glm(avg_like ~ poly(huMech, 4),</span>
  <span class="co">#          data = ., iter = 200)</span>

P_poly &lt;-<span class="st"> </span><span class="kw">posterior</span>(M_poly)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Uncanny$P_1 %&gt;% </span>
<span class="co">#   mutate(parameter = str_replace(parameter, &quot;Intercept&quot;, &quot;huMech_0&quot;),</span>
<span class="co">#          fixef = str_replace(fixef, &quot;Intercept&quot;, &quot;huMech_0&quot;))</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(polynom)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T_fixef_<span class="dv">1</span> &lt;-<span class="st"> </span><span class="kw">fixef</span>(P_poly)
T_fixef_<span class="dv">1</span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">-0.207</td>
<td align="right">-0.337</td>
<td align="right">-0.093</td>
</tr>
<tr class="even">
<td align="left">huMech_1</td>
<td align="right">-0.525</td>
<td align="right">-0.763</td>
<td align="right">-0.281</td>
</tr>
<tr class="odd">
<td align="left">huMech_2</td>
<td align="right">0.293</td>
<td align="right">0.060</td>
<td align="right">0.577</td>
</tr>
<tr class="even">
<td align="left">huMech_3</td>
<td align="right">0.744</td>
<td align="right">0.368</td>
<td align="right">1.133</td>
</tr>
</tbody>
</table>
<p>We can extract the fixef effects table as usual. The four coefficients specify the polynomial to approximate the average likability responses. The polynomial parameters have little explanatory value. Neither of the parameter alone relates to a relevant property of the uncanny valley. One relevant property would be the location of the deepest point of the uncanny valley, its trough. The trough is a local minimum of the curve and with polynomial techniques, we can find this point.</p>
<p>Finding a local minimum is a two step procedure: first, we must find all <em>stationary points</em>, which includes local minima and maxima. Then, we determine which of the resulting points is the local minimum. Stationary points occur, where the curve bends from a rising to falling, or vice versa. They are distinguishable by having a slope of zero, neither rising nor falling. Stationary points can be identified by the derivative of the third degree polynomial, which is a second degree polynomial:</p>
<p><span class="math display">\[f&#39;(x) = \beta_1 + 2\beta_2x + 3\beta_2x^2\]</span></p>
<p>The derivative <span class="math inline">\(f&#39;(x)\)</span> of a function <span class="math inline">\(f(x)\)</span> gives the slope of <span class="math inline">\(f(x)\)</span> at any given point <span class="math inline">\(x\)</span>. When <span class="math inline">\(f&#39;(x) &gt; 0\)</span>, <span class="math inline">\(f(x)\)</span> is rising at <span class="math inline">\(x\)</span>, with <span class="math inline">\(f&#39;(x) &lt; 0\)</span> it is falling. Stationary points are precisely those points, where <span class="math inline">\(f&#39;(x) = 0\)</span> and can be found by solving the equation. The derivative of a third degree polynomial is of the second degree, which has a quadratic part. This can produce a parabolic form, which hits point zero twice, during rise and when falling. A rising encounter of point zero indicates that <span class="math inline">\(f(x)\)</span> has a local minimum at <span class="math inline">\(x\)</span>, a local maximum when falling. In consequence, solving <span class="math inline">\(f&#39;(x) = 0\)</span> can result in two solutions, one minimum and one maximum, which needs to be distinguished further.</p>
<p>If the stationary point is a local minimum, as the trough, slope switches from negative to positive; <span class="math inline">\(f&#39;(x)\)</span> crosses <span class="math inline">\(x = 0\)</span> in a rising manner, which is a positive slope of <span class="math inline">\(f&#39;(x)\)</span>. Therefore, a stationary point is a local minimum, when of <span class="math inline">\(f&#39;&#39;(x) &gt; 0\)</span>.</p>
<p>Mathur et al. followed these analytic steps to arrive at an estimate for the position of the trough. The following code uses several high-level functions from package <code>polynom</code> to estimate the location of the trough, by drawing on the first and second derivative <code>d[d]poly</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">poly     =<span class="st"> </span><span class="kw">polynomial</span>(T_fixef_<span class="dv">1</span><span class="op">$</span>center) <span class="co"># UC function on center</span>
dpoly    =<span class="st"> </span><span class="kw">deriv</span>(poly)                  <span class="co"># 1st derivative</span>
ddpoly   =<span class="st"> </span><span class="kw">deriv</span>(dpoly)                 <span class="co"># 2nd derivative</span>
stat_pts =<span class="st"> </span><span class="kw">solve</span>(dpoly)                 <span class="co"># finding stat points</span>
slopes   =<span class="st"> </span><span class="kw">as.function</span>(ddpoly)(stat_pts)<span class="co"># slope at stat points</span>
trough   =<span class="st"> </span>stat_pts[slopes <span class="op">&gt;</span><span class="st"> </span><span class="dv">0</span>]         <span class="co"># selecting the local minimum</span>

<span class="kw">cat</span>(<span class="st">&quot;The trough is most likely at a huMech score of &quot;</span>, <span class="kw">round</span>(trough, <span class="dv">2</span>))</code></pre></div>
<pre><code>## The trough is most likely at a huMech score of  0.37</code></pre>
<p>While this procedure is instructive, there is an issue: drawing on the center estimates, which is a summary of the PD, we get a point estimate, only. Statements on certainty are impossible, as a CI is lacking. Recall the 99 seconds study, where we operated directly on the PD to obtain more specific statements on certainty. Another case for directly operating on the PD samples is to calculate additional statistics. It is another virtue of the MCMC method, that this is possible.</p>
<p>Every PD sample contains simultaneous draw of the four parameters <code>huMech_[0:3]</code>, and therefore fully specifies its own third degree polynomial. A PD for the trough parameter can be obtained by performing the above procedure on every sample separately. For the convenience, the case study Uncanny contains a function <code>trough(coef)</code> that includes all the above steps. The following code creates a data frame with one row per MCMC draw and the four huMech variables, the function <code>trough</code> acts on this data frame as a matrix of coefficients and returns one trough point per row. We have obtained the PD of the trough.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">P_trough &lt;-
<span class="st">  </span>P_poly <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">filter</span>(type <span class="op">==</span><span class="st"> &quot;fixef&quot;</span>) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">select</span>(chain, iter, fixef, value) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">spread</span>(fixef, value) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(Intercept, <span class="kw">starts_with</span>(<span class="st">&quot;huMech&quot;</span>)) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">trough</span>()</code></pre></div>
<p>From the PD, we can derive statements on uncertainty in the usual way: the 95% credibility limits we get by:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">quantile</span>(P_trough, <span class="kw">c</span>(.<span class="dv">025</span>, <span class="fl">0.5</span>, .<span class="dv">975</span>), <span class="dt">na.rm =</span> T) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">kable</span>()</code></pre></div>
<table>
<thead>
<tr class="header">
<th></th>
<th align="right">x</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>2.5%</td>
<td align="right">0.271</td>
</tr>
<tr class="even">
<td>50%</td>
<td align="right">0.367</td>
</tr>
<tr class="odd">
<td>97.5%</td>
<td align="right">0.479</td>
</tr>
</tbody>
</table>
<p>The 95% CI is a conventional measure of uncertainty and may be more or less irrelevant for the spectator. The most generous account on uncertainty is a density plot on the full posterior. The density function just smooths over the frequency distribution of trough draws, but makes no arbitrary choices on where to cut it.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">grid.arrange</span>(
  UV_<span class="dv">1</span> <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> huMech, <span class="dt">y =</span> avg_like)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_point</span>(<span class="dt">size =</span> .<span class="dv">3</span>) <span class="op">+</span>
<span class="st">    </span><span class="kw">xlim</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>),
  
  <span class="kw">data_frame</span>(<span class="dt">trough =</span> P_trough) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> trough)) <span class="op">+</span>
<span class="st">    </span><span class="kw">geom_density</span>(<span class="kw">aes</span>(<span class="dt">x =</span> trough)) <span class="op">+</span>
<span class="st">    </span><span class="kw">xlim</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>)
)</code></pre></div>
<p><img src="Classic_linear_models_files/figure-html/unnamed-chunk-103-1.png" width="672" /></p>
<p>With reasonable certainty, we can say that the trough is at approximately two-thirds of the huMech score range. The illustration of the uncanny valley as they used to be perpetuated from the original source, place the trough at about four quarters of the scale. We clearly see that this is not the case in Mathur’s study. This might be an artifact, for example in that the huMech score is not linearly related to the perception of human-likeness.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detach</span>(Uncanny)</code></pre></div>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="getting-started-r.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="multilevel-models.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"linkedin": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["New_Stats.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(src))
      src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
