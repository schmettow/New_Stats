<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta property="og:title" content="3.2 Learning R: a primer | New statistics for the design researcher" />
<meta property="og:type" content="book" />


<meta property="og:description" content="A statistics book for designers, human factors specialists, UX researchers, applied psychologists and everyone else who works hard to make this world a better place." />
<meta name="github-repo" content="schmettow/New_Stats" />

<meta name="author" content="Martin Schmettow" />

<meta name="date" content="2020-05-06" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

<meta name="description" content="A statistics book for designers, human factors specialists, UX researchers, applied psychologists and everyone else who works hard to make this world a better place.">

<title>3.2 Learning R: a primer | New statistics for the design researcher</title>

<link href="libs/tufte-css-2015.12.29/tufte-fonts.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-background.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte-italics.css" rel="stylesheet" />
<link href="libs/tufte-css-2015.12.29/tufte.css" rel="stylesheet" />





</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li class="part"><span><b>I Preparations</b></span></li>
<li class="has-sub"><a href="index.html#introduction"><span class="toc-section-number">1</span> Introduction</a><ul>
<li class="has-sub"><a href="1-1-whom-this-book-is-for.html#whom-this-book-is-for"><span class="toc-section-number">1.1</span> Whom this book is for</a><ul>
<li><a href="1-1-whom-this-book-is-for.html#the-empirical-design-researcher"><span class="toc-section-number">1.1.1</span> The empirical design researcher</a></li>
<li><a href="1-1-whom-this-book-is-for.html#the-experimentalist"><span class="toc-section-number">1.1.2</span> The experimentalist</a></li>
<li><a href="1-1-whom-this-book-is-for.html#the-applied-researcher"><span class="toc-section-number">1.1.3</span> The applied researcher</a></li>
</ul></li>
<li><a href="1-2-assumptions.html#assumptions"><span class="toc-section-number">1.2</span> Assumptions</a></li>
<li><a href="1-3-how-to-read-this-book.html#how-to-read-this-book"><span class="toc-section-number">1.3</span> How to read this book</a></li>
<li><a href="1-4-quantitative-design-research.html#quantitative-design-research"><span class="toc-section-number">1.4</span> Quantitative design research</a></li>
<li><a href="1-5-studies.html#studies"><span class="toc-section-number">1.5</span> Studies</a></li>
<li class="has-sub"><a href="1-6-observations-and-measurestbc.html#observations-and-measurestbc"><span class="toc-section-number">1.6</span> Observations and measures[TBC]</a><ul>
<li><a href="1-6-observations-and-measurestbc.html#interaction-sequences"><span class="toc-section-number">1.6.1</span> Interaction sequences</a></li>
<li><a href="1-6-observations-and-measurestbc.html#performance-measures"><span class="toc-section-number">1.6.2</span> performance measures</a></li>
<li><a href="1-6-observations-and-measurestbc.html#experience-tbd"><span class="toc-section-number">1.6.3</span> experience [TBD]</a></li>
<li><a href="1-6-observations-and-measurestbc.html#design-features-tbd"><span class="toc-section-number">1.6.4</span> design features [TBD]</a></li>
<li><a href="1-6-observations-and-measurestbc.html#the-human-factor-tbd"><span class="toc-section-number">1.6.5</span> the human factor [TBD]</a></li>
<li><a href="1-6-observations-and-measurestbc.html#situations-tbd"><span class="toc-section-number">1.6.6</span> situations [TBD]</a></li>
</ul></li>
</ul></li>
<li><a href="2-elements-of-bayesian-statistics.html#elements-of-bayesian-statistics"><span class="toc-section-number">2</span> Elements of Bayesian Statistics</a></li>
<li class="has-sub"><a href="3-getting-started-r.html#getting_started_r"><span class="toc-section-number">3</span> Getting started with R</a><ul>
<li class="has-sub"><a href="3-1-setting-up-the-r-environment.html#setting-up-the-r-environment"><span class="toc-section-number">3.1</span> Setting up the R environment</a><ul>
<li><a href="3-1-setting-up-the-r-environment.html#installing-cran-packages"><span class="toc-section-number">3.1.1</span> Installing CRAN packages</a></li>
<li><a href="3-1-setting-up-the-r-environment.html#installing-packages-from-github"><span class="toc-section-number">3.1.2</span> Installing packages from Github</a></li>
<li><a href="3-1-setting-up-the-r-environment.html#first_program"><span class="toc-section-number">3.1.3</span> A first statistical program</a></li>
<li><a href="3-1-setting-up-the-r-environment.html#bibliographic-notes"><span class="toc-section-number">3.1.4</span> Bibliographic notes</a></li>
</ul></li>
<li class="has-sub"><a href="3-2-learning-r-a-primer.html#learning-r-a-primer"><span class="toc-section-number">3.2</span> Learning R: a primer</a><ul>
<li><a href="3-2-learning-r-a-primer.html#assigning-and-calling-objects"><span class="toc-section-number">3.2.1</span> Assigning and calling Objects</a></li>
<li><a href="3-2-learning-r-a-primer.html#vectors"><span class="toc-section-number">3.2.2</span> Vectors</a></li>
<li><a href="3-2-learning-r-a-primer.html#basic-object-types"><span class="toc-section-number">3.2.3</span> Basic object types</a></li>
<li><a href="3-2-learning-r-a-primer.html#operators-and-functions"><span class="toc-section-number">3.2.4</span> Operators and functions</a></li>
<li><a href="3-2-learning-r-a-primer.html#storing-data-in-data-frames"><span class="toc-section-number">3.2.5</span> Storing data in data frames</a></li>
<li><a href="3-2-learning-r-a-primer.html#import-export-and-archiving"><span class="toc-section-number">3.2.6</span> Import, export and archiving</a></li>
<li><a href="3-2-learning-r-a-primer.html#case-environments"><span class="toc-section-number">3.2.7</span> Case environments</a></li>
<li><a href="3-2-learning-r-a-primer.html#structuring-data"><span class="toc-section-number">3.2.8</span> Structuring data</a></li>
<li><a href="3-2-learning-r-a-primer.html#data-transformation"><span class="toc-section-number">3.2.9</span> Data transformation</a></li>
<li><a href="3-2-learning-r-a-primer.html#plotting-data"><span class="toc-section-number">3.2.10</span> Plotting data</a></li>
<li><a href="3-2-learning-r-a-primer.html#fitting-regression-models"><span class="toc-section-number">3.2.11</span> Fitting regression models</a></li>
<li><a href="3-2-learning-r-a-primer.html#knitting-statistical-reports"><span class="toc-section-number">3.2.12</span> Knitting statistical reports</a></li>
<li><a href="3-2-learning-r-a-primer.html#exercises"><span class="toc-section-number">3.2.13</span> Exercises</a></li>
<li><a href="3-2-learning-r-a-primer.html#bibliographic-notes-1"><span class="toc-section-number">3.2.14</span> Bibliographic notes</a></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="learning-r-a-primer" class="section level2">
<h2><span class="header-section-number">3.2</span> Learning R: a primer</h2>
<blockquote>
<p>cRazy as in ‘idiosyncrasy’</p>
</blockquote>
<p>This book is for applied researchers in design sciences, whose frequent task is to analyze data and report it to stakeholders. Consequently, the way I use R in this book capitalizes on interactive data analysis and reporting. As it turns out, a small fraction of R, mostly from the tidyverse, is sufficient to write R code that is effective and fully transparent. In most cases, a short chain of simple data transformations tidies the raw data which can then be pushed into a modelling or graphics engine that will do the hard work. We will not bother (ourselves and others) with usual programming concepts such as conditionals, loops or the somewhat eccentric approaches to functional programming. At the same time, we can almost ignore all the clever and advanced routines that underlay statistical inference and production of graphics, as others have done the hard work for us.</p>
<p>R mainly serves three purposes, from easy to advanced:
1. interactive data analysis
2. creating data analysis reports
3. developing new statistical routines.</p>
<p>It turns out that creating multimedia reports in R has become very easy by the knitr/markdown framework that is neatly integrated into the Rstudio environment. I</p>
<p>With R one typically <em>works interactively through a data analysis</em>. The analysis often is a rather routine series of steps, like:</p>
<ol style="list-style-type: decimal">
<li>load the data</li>
<li>make a scatter plot</li>
<li>run a regression</li>
<li>create a coefficient table</li>
</ol>
<p>A program in R is usually developed iteratively: once you’ve loaded and checked your data, you progress to the next step step of your analysis, test it and proceed. At every step, one or more new objects are created in the environment, capturing intermediate and final results of the analysis:</p>
<ol style="list-style-type: decimal">
<li>a data frame holding the data</li>
<li>a graphics object holding a scatterplot</li>
<li>a model object holding the results of a regression analysis</li>
<li>a data frame for the coefficient table</li>
</ol>
<p>As R is an interpreter language, meaning there is no tedious compile-and-run cycles in everyday R programming. You develop the analysis as it happens. It is even normal to jump back and forth in an R program, while building it.</p>
<p>R is a way to <em>report and archive</em> what precisely you have been doing with your data. In statistics, mathematical formulas are the common form of unambiguously describing a statistical model. For example, the following equation defines a linear regression model between the observed outcome <span class="math inline">\(y\)</span> and the predictor <span class="math inline">\(x\)</span>:</p>
<p><span class="math display">\[
\mu_i = \beta_0 +  \beta_1x_i\\
y_i \sim N(\mu_i, \sigma)
\]</span></p>
<p>As we will later see [CLM], in Rs formula language the same model is unambiguously specified as:</p>
<p><code>y ~ x</code></p>
<p>R is currently the <em>lingua franca</em> of statistical computing. As a programming language, R has the same precision as math, but is more expressive. You can specify complex models, but also graphics and the steps of data checking and preparation. As an example, consider an outlier removal rule of:</p>
<blockquote>
<blockquote>
<p>An observation is valid if it does not exceed the tenfold of the observation mean.</p>
</blockquote>
</blockquote>
<p>We just applied our own rule of outlier removal to the data. Others may consider this rule invalid or arbitrary. Disagreement is virtue in science and one can only disagree with what one actually sees. In R, the researcher <em>formally reports</em> what precisely has been done with the data. For example, the same outlier removal rule is unambiguously specified by the following code (the first line just simulates some data).</p>
<table>
<thead>
<tr class="header">
<th align="right">score</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">2</td>
</tr>
<tr class="odd">
<td align="right">4</td>
</tr>
<tr class="even">
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="right">5</td>
</tr>
<tr class="even">
<td align="right">6</td>
</tr>
<tr class="odd">
<td align="right">50</td>
</tr>
</tbody>
</table>
<p>Finally, R is a way to <em>develop and share statistical programs</em>. Thousands of packages in the R ecosystem cover almost all statistical problems you can imagine. As a programming language, R has been designed for that particular purpose. Under the hood of R, a bunch of generic, yet powerful, principles purr to make it a convenient language for typical problems in statistical computation. Readers with programming experience can fly over the R basics that follow. But, as a specific purpose language R has a few idiosyncracies you should know about:</p>
<p>Almost all programming languages the first element of a list has the index zero. We got used to it, but for beginners it is a another hurdle that is unnecessary. Mathematicians, catholiques, software developers in bars and everyone, young or old, counts</p>
<blockquote>
<blockquote>
<p>“one”, “two” ,“three”.</p>
</blockquote>
</blockquote>
<p>And so does R:</p>
<pre><code>## [1] 1 2 3</code></pre>
<p>Counting from one is perhaps the most lovable idiosyncracy of R. But, lets also welcome people who have experience with other programming languages:</p>
<p>The first thing one has to know about R is that it is a <em>functional programming</em> language. A function simply is a programmed procedure that takes data as input, applies some transformation and returns data as output. That sounds trivial, but there is an important difference to most other languages: Different to procedures in Pascal or object oriented methods (in Java or Python), functions are forbidden to modify any external object. A certain function is a black box, but one can be sure that the only thing it does is return a new object.</p>
<p>At the same time, functions are first-class citizens in R and can be called everywhere, even as an <em>argument to another function</em>. The <em>plyr</em> package is famous for functions that call functions, also called high-level functions. The following three liner makes heavy use of high level functions. First, a list of binary matrices is generated by repeatedly calling a random number generator, then the row sum of all matrices is computed and returned as a (new) list.</p>
<pre><code>## [[1]]
##  [1] 1 0 1 0 0 0 0 0 0 1 0 0 1 0 0 0 0 1 0 0 1 1 0 1 0
## 
## [[2]]
##  [1] 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 1 0 0 0 0 1 1 1 0 0 0 0 1 0
## 
## [[3]]
##  [1] 0 1 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 1 1 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 1
## [39] 1 0 0 1 0 0 1 0 0 0 0</code></pre>
<p>What we have seen is a routine application of higher level functions: apply a transformation to a sequence of data sets. In a majority of programming languages you had to write a loop instead and this is why experienced programmers can easily fall for the active user paradox when they learn R, by sticking to loops. Believe me one thing: Once you have wrapped your head around functional programming, you will program the same procedure in a quarter of time with half the code and your program will run significantly faster. My general advice is:</p>
<blockquote>
<blockquote>
<p>Whenever you think you need a loop, you don’t.</p>
</blockquote>
</blockquote>
<p>For me it helped to imagine the following: loops carry the notion of chain of data that moves over a fixed transformation device. In functional programing functions the can work in a hierarchy, a high-level device moves along a string of data. It carries an exchangeable low-level device that applies the desired transformation to every position.</p>
<p>If you come from relational data bases you you have something in common with the statistician: you both think in transformation of tables. Not coincidently, the features in <em>dplyr</em>, the tidy data transformation engine, are clearly borrowed from SQL. You will also feel at home with the idea of reports powered by functional chunks embedded in a templating system.</p>
<p>For object orientation folks, R is a good choice, but you have to get used to it. First, it gives you the choice of several object orientation systems, which sometimes requires to install a package. The so-called <em>S3 system</em> is the original. It is rather limited and some even call it informal. The approach is as simple as it is unusal. S3 mainly is a raw method dispatcher that can handles overloading of functions. S3 puts methods first, then objects, whereas in traditional object orientation, the method belongs to the class, making the object “knows” its methods. In S3, the object and the method both know their class. When calling an S3 method, you actually call a generic method that finds the matching method and applies it.</p>
<p>Beginners are at peace with all of this. You can count like you do. Functional programming is intuitive for working on research data. And because of S3 the function <code>summary</code> always does something useful.</p>
<div id="assigning-and-calling-objects" class="section level3">
<h3><span class="header-section-number">3.2.1</span> Assigning and calling Objects</h3>
<p>Any statistical analysis can be thought of as a production chain. You take the raw data and process it into a neat data table, which you feed into graphics and regression engines or summarize by other means. At almost every step there is an input and an output object.</p>
<p><em>Objects</em> are a basic feature of R. They are temporary storage places in the computer’s memory. Objects always have a name chosen by the programmer. By its name, a stored object can be found back at any time. Two basic operations apply for all objects: an object is stored by <em>assigning</em> it a name and it is retrieved by <em>calling</em> its name. If you wanted to store the number of observations in your data set under the name <code>N_obs</code>, you use the assignment operator <code>&lt;-</code>. The name of the variable is left of the operator, the assigned value is right of it.</p>
<p>Now, that the value is stored, you can call it any time by simply calling its name:</p>
<pre><code>## [1] 100</code></pre>
<p>Just calling the name prints the value to Console. In typical interactive programming sessions with R, this is already quite useful. But, you can do much more with this mechanism.</p>
<p>Often, what you want is to do calculations with the value. For example, you have a repeated measures study and want to calculate the average number of observations per participant. For this you need the number of observations, and the number of participants. The below code creates both objects, does the calculation (right of <code>&lt;-</code>) and stores it in another object <code>avg_N_Obs</code></p>
<pre><code>## [1] 4</code></pre>
<p>Objects can exist without a name, but are volatile, then. They cannot be used any further. The following arithmetic operation does create an object, a single number. For a moment or so this number exists somewhere in your computers memory, but once it is printed to the screen, it is gone. Of course, the same expression can be called again, resulting in the same number. But, strictly, it is a different object.</p>
<pre><code>## [1] 4</code></pre>
<pre><code>## [1] 4</code></pre>
<p>There even is a formal way to show that the two numbers, although having the same value assigned, are located at different addresses. This is just for the purpose of demonstration and you will rarely use it in everyday programming tasks:</p>
<pre><code>## [1] &quot;&lt;0000000038B14008&gt;&quot;</code></pre>
<pre><code>## [1] &quot;&lt;0000000038ACA1F0&gt;&quot;</code></pre>
</div>
<div id="vectors" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Vectors</h3>
<p>Notice the <code>[1]</code> that R put in front of the single value when printing it? This is an <em>index</em>. Different to other programming languages, all basic data types are <em>vectors</em> in R. Vectors are containers for storing many values <em>of the same type</em>. The values are addressed by the index, <code>N_Obs[1]</code> calls the first element. In R, <em>indices start counting with 1</em>, which is different to most other languages that start at zero. And if you have a single value only, this is just a vector of length one.</p>
<p>For statistics programming having vectors as basic data types makes perfect sense. Any statistical data is a collection of values. What holds for data is also true for functions applied to data. Practically all frequently used mathematical functions work on vectors, take the following example:</p>
<pre><code>## [1] 1.88</code></pre>
<p>The <code>rnorm</code> command <em>produces</em> a vector of length 100 from three values. More precisely, it does 100 random draws from a normal distribution with mean 2 and an SD of 1. The <code>mean</code> command takes the collection and <em>reduces</em> it to a single value. By the way, this is precisely, what we call <em>a statistic: a single quantity that characterizes a collection of quantities</em>.</p>
</div>
<div id="basic-object-types" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Basic object types</h3>
<p>Objects can be of various <em>classes</em>. In R the common basic classes are: logical, factor, character, integer and numeric. Besides that, programmers can define their own complex classes, for example, to store the results of regression models.</p>
<p>Objects of type <em>logical</em> store the two levels <code>TRUE</code>, <code>FALSE</code>, like presence or absence of a treatment, or passed and failed test items. With Boolean operators one can compute new logical values, for example</p>
<pre><code>## [1] FALSE</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>More generally, logical values can be used for categorization, when their are only two categories, which is called a <em>dichotomous variable</em>. For example, gender is usually coded as a vector of characters (<code>"m", "f", "f"</code>), but one can always do:</p>
<p>Programmers are lazy folks when it comes to typing, therefore R allows you to abbreviate <code>TRUE</code> and <code>FALSE</code> as shown above. As a consequence, one should never assign objects the name reserved for logical values, so don’t do one of the following:</p>
<p>The class <code>numeric</code> stores real numbers and is therefore abundant in statistical programming. All the usual arithmetic operations apply:</p>
<pre><code>## [1] 1.41</code></pre>
<p>Objects of class <code>integer</code> are more specific as they store natural numbers, only. This often occurs as counts, ranks or indices.</p>
<pre><code>## [1] 1 3 2</code></pre>
<p>The usual arithmetic operations apply, although the result of operation may no longer be <code>integer</code>, but <code>numeric</code></p>
<pre><code>## [1] 10.7</code></pre>
<pre><code>## [1] &quot;numeric&quot;</code></pre>
<p>Surprisingly, logical values can be used in arithmetic expressions, too. When R encounters value <code>TRUE</code> in an arithmetic context, it replaces it with 1, zero otherwise. Used with multiplication, this acts like an on/off switch, which we will use in [LM: dummy variables].</p>
<pre><code>## [1] 2</code></pre>
<pre><code>## [1] 2</code></pre>
<pre><code>## [1] 4 4 2</code></pre>
<p>Data sets usually contain variables that are not numeric, but partition the data into groups. For example, we frequently group observations by the following</p>
<ul>
<li><code>Part</code>: participant</li>
<li><code>Condition</code>: experimental condition</li>
<li><code>Design</code>: one of several designs</li>
<li><code>Education</code>: level of education (e.g., low, middle or high)</li>
</ul>
<p>Two object types apply for grouping observations: <em>factor</em> and <em>character</em>. While factors specialize on grouping observations, character objects can also be used to store longer text, say the description of a usability problem. The following identifies two conditions in a study, say a comparison of designs A and B. Note how the factor identifies its <em>levels</em> when called to the screen:</p>
<pre><code>## [1] &quot;A&quot; &quot;B&quot; &quot;B&quot; &quot;A&quot;</code></pre>
<pre><code>## [1] A B B A
## Levels: A B</code></pre>
<p>Statistical analyses deal with real world data which ever so often is messy. Frequently, a planned observation could not be recorded, because the participant decided to quit or the equipment did not work properly or the internet collapsed. Users of certain legacy statistics packages got used to coding missing observations as <code>-999</code> and then declared this a missing value. In R <em>missing values are first-class citizens</em>. Every vector of a certain class can contain missing values, which are identified as <code>NA</code>.</p>
<p>Most basic statistics functions, like <code>mean()</code>, <code>sd()</code> or <code>median()</code> are act conservatively when the data contains missing values. If there is a single <code>NA</code> in the variable to be summarized, the result is <code>NA</code>. While this is good in the sense of transparency, much of the time what the researcher wants is to have the summary statistic with <code>NA</code> values being removed, first.</p>
<pre><code>## [1] NA</code></pre>
<pre><code>## [1] 2.5</code></pre>
<p>This book is about programming and statistics at the same time. Unfortunately, there are a few terms that have a particular meaning in both domains. One of those is a “variable”. In statistics, a variable usually is a property we have recorded, say the body length of persons, or their gender. In general programming, a variable is a space in the computers memories, where results can be stored and recalled. Fortunately, R avoids any confusion and calls <em>objects</em> what is usually called a programming variable.</p>
</div>
<div id="operators-and-functions" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Operators and functions</h3>
<p>R comes with a full bunch of functions for creating and summarizing data. Let me first introduce you to functions that produce exactly one number to characterize a vector. The following functions do that with to the vector <code>X</code>, every in their own way:</p>
<p>These functions are a transformation of data. The input to these transformations is <code>X</code> and is given as an <em>argument</em> to the function. Other functions require more than one argument. The <code>quantile</code> function is routinely used to summarize a variable. Recall that <code>X</code> has been drawn from a Normal distribution of <span class="math inline">\(\mu=2\)</span> and standard deviation <span class="math inline">\(\sigma = 1\)</span>. All Normal distributions have the property that about 66% of the mass is within the range of <span class="math inline">\(\mu-\sigma\)</span> and <span class="math inline">\(\mu+\sigma\)</span> <!-- #9 -->. That means in turn: 17% are below <span class="math inline">\(\mu-\sigma\)</span> and 66 + 17 = 83% are <em>below</em> <span class="math inline">\(\mu+\sigma\)</span>. The number of observations in a certain range of values is called a <em>quantile</em>. The <code>quantile</code> function operates on X, but takes an (optional) vector of quantiles as second argument:</p>
<pre><code>##   17%   83% 
## 0.984 2.947</code></pre>
<p>Most functions in R have <em>optional arguments</em> that let you change how the function performs. The basic mathematical functions all have the optional argument <code>na.rm</code>. This is a switch that determines how the function deals with missing values <code>NA</code>. Many optional arguments have <em>defaults</em>. The default of <code>na.rm</code> is <code>FALSE</code> (“return NA in case of NAs in the vector”). By setting it to <code>TRUE</code>, they are removed before operation.</p>
<pre><code>## [1] NA</code></pre>
<pre><code>## [1] 2</code></pre>
<p>Most more complex routines in R have an abundance of parameters, most of which have reasonable defaults, fortunately. To give a more complex example, the first call of <code>stan_glm</code> performs a Bayesian estimation of the grand mean model. The second does a
Poisson grand mean model with 5000 iterations per MCMC chain. As <code>seed</code> has been fixed, every subsequent run will produce the exact same chains. My apologies for the jargon! <!-- #10 --></p>
<p>R brings the usual set of arithmetic operators, like <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and more. In fact, an operator is just a function. The sum of two numbers can, indeed, be written in these two ways:</p>
<pre><code>## [1] 3</code></pre>
<pre><code>## [1] 3</code></pre>
<p>The second term is a function that takes two numbers as input and returns a third. It is just a different syntax, and this one is called the <em>polish notation</em>. I will never use it throughout the rest of this book.</p>
<p>Another set of commonly used operators are logical, they implement <em>Boolean algebra</em>. Some common Boolean operators are shown in the truth table:</p>
<table>
<thead>
<tr class="header">
<th>A</th>
<th>B</th>
<th>!A</th>
<th>A &amp; B</th>
<th>A | B</th>
<th>A == B</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td></td>
<td></td>
<td>not</td>
<td>and</td>
<td>or</td>
<td>equals</td>
</tr>
<tr class="even">
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>T</td>
<td>T</td>
</tr>
<tr class="odd">
<td>T</td>
<td>F</td>
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr class="even">
<td>F</td>
<td>T</td>
<td>T</td>
<td>F</td>
<td>T</td>
<td>F</td>
</tr>
<tr class="odd">
<td>F</td>
<td>F</td>
<td>T</td>
<td>F</td>
<td>F</td>
<td>T</td>
</tr>
</tbody>
</table>
<p>Be careful not to confuse Boolean “and” and “or” with their common natural language use. If you ask: “Can you buy apples <em>or</em> pears on the market?”, the natural answer would be: “both”. The Boolean answer is: TRUE. In a requirements document you could state “This app is for children and adults”. In Boolean the answer would be FALSE, because no one can be a child and an adult at the same time, strictly. A correct Boolean statement would be: “The envisioned users can be adult or child”. <!-- #11 --></p>
<p>Further Boolean operators exist, but can be derived from the three above. For example, the exclusive OR, “either A or B” can be written as: <code>(A | B) &amp; !(A &amp; B)</code>. This term only gets TRUE when A or B is TRUE, but not both. In the data analysis workflow, Boolean logic is frequently used for filtering data and we re-encounter them in data transformation.</p>
<p>Finally, it sometimes is convenient or necessary to program own functions. A full coverage of developing functions is beyond the scope of this introduction, so I show just one simple example. If one desires a more convenient function to compute the mean that ignore missing values by default, this can be constructed as follows:</p>
<pre><code>## [1] 2</code></pre>
<p>Notice that:</p>
<ul>
<li>the <code>function()</code> function creates new functions</li>
<li>the arguments given to <code>function(x)</code> will be the arguments expected by the function <code>mean_conv(x)</code>.</li>
<li>code enclosed by</li>
</ul>
<p>More examples of creating basic functions can be found in section @ref(descriptive_stats). As R is a functional programming language, it offers very elaborate ways of programming functions, way beyond what is found in common languages, such as Python or Java. An advanced example is given in section @ref(forecasting_LOO).</p>
</div>
<div id="storing-data-in-data-frames" class="section level3">
<h3><span class="header-section-number">3.2.5</span> Storing data in data frames</h3>
<p>Most behavioral research collects <em>real data</em> to work with. As behavior researchers are obsessed about finding associations between variables, real data usually contains several. If you have a sample of observations (e.g. participants) and every case has the same variables (measures or groups), data is stored in a table structure, where columns are variables and rows are observations.</p>
<p>R knows the <code>data.frame</code> objects to store variable-by-observation tables. Data frames are tables, where columns represent statistical variables. Variables have names and can be of different data types, as they usually appear in empirical research. In many cases data frames are imported to R, as they represent real data. Here, we first see how to create data frames by simulation. First, we usually want some initial inspection of a freshly harvested data frame.</p>
<p>Data frames are objects. By just calling a data frame it gets printed to the screen. This is a good moment to reflect on one idiosyncrasy in R, a feature, of course.
R is primarily used interactively, which has the immense advantage that the programmer can incrementally build the data analysis. This implies, that the programmer often wants to quickly check what currently is in a variable. Now, observe what happens when we call <code>Experiment</code>:</p>
<table>
<thead>
<tr class="header">
<th align="left">Group</th>
<th align="right">age</th>
<th align="right">outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">control</td>
<td align="right">21</td>
<td align="right">228</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">20</td>
<td align="right">258</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">21</td>
<td align="right">204</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">19</td>
<td align="right">256</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">27</td>
<td align="right">221</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">21</td>
<td align="right">269</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">33</td>
<td align="right">208</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">34</td>
<td align="right">252</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">24</td>
<td align="right">229</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">18</td>
<td align="right">254</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">30</td>
<td align="right">219</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">27</td>
<td align="right">262</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">19</td>
<td align="right">198</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">23</td>
<td align="right">253</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">19</td>
<td align="right">209</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">19</td>
<td align="right">240</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">29</td>
<td align="right">198</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">24</td>
<td align="right">267</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">23</td>
<td align="right">218</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">24</td>
<td align="right">252</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">26</td>
<td align="right">188</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">20</td>
<td align="right">240</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">33</td>
<td align="right">212</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">34</td>
<td align="right">227</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">27</td>
<td align="right">204</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">30</td>
<td align="right">242</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">27</td>
<td align="right">216</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">25</td>
<td align="right">247</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">35</td>
<td align="right">203</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">21</td>
<td align="right">273</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">33</td>
<td align="right">192</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">35</td>
<td align="right">250</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">28</td>
<td align="right">199</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">30</td>
<td align="right">248</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">22</td>
<td align="right">211</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">20</td>
<td align="right">275</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">30</td>
<td align="right">209</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">25</td>
<td align="right">257</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">30</td>
<td align="right">220</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">34</td>
<td align="right">248</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">25</td>
<td align="right">210</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">28</td>
<td align="right">256</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">23</td>
<td align="right">209</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">18</td>
<td align="right">251</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">22</td>
<td align="right">205</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">25</td>
<td align="right">246</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">32</td>
<td align="right">211</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">19</td>
<td align="right">249</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">31</td>
<td align="right">223</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">26</td>
<td align="right">239</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">34</td>
<td align="right">213</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">20</td>
<td align="right">261</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">20</td>
<td align="right">200</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">29</td>
<td align="right">236</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">28</td>
<td align="right">215</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">18</td>
<td align="right">272</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">27</td>
<td align="right">207</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">27</td>
<td align="right">260</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">33</td>
<td align="right">220</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">26</td>
<td align="right">251</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">29</td>
<td align="right">216</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">22</td>
<td align="right">222</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">33</td>
<td align="right">226</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">24</td>
<td align="right">254</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">32</td>
<td align="right">214</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">35</td>
<td align="right">237</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">18</td>
<td align="right">214</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">24</td>
<td align="right">235</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">23</td>
<td align="right">210</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">29</td>
<td align="right">267</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">34</td>
<td align="right">208</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">30</td>
<td align="right">270</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">23</td>
<td align="right">201</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">20</td>
<td align="right">252</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">33</td>
<td align="right">210</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">33</td>
<td align="right">259</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">23</td>
<td align="right">196</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">33</td>
<td align="right">264</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">31</td>
<td align="right">224</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">33</td>
<td align="right">230</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">34</td>
<td align="right">208</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">27</td>
<td align="right">247</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">20</td>
<td align="right">201</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">25</td>
<td align="right">254</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">34</td>
<td align="right">210</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">30</td>
<td align="right">267</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">34</td>
<td align="right">200</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">35</td>
<td align="right">244</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">24</td>
<td align="right">221</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">28</td>
<td align="right">259</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">25</td>
<td align="right">219</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">24</td>
<td align="right">267</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">25</td>
<td align="right">204</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">32</td>
<td align="right">259</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">25</td>
<td align="right">212</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">25</td>
<td align="right">249</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">35</td>
<td align="right">208</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">21</td>
<td align="right">236</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">33</td>
<td align="right">200</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">30</td>
<td align="right">251</td>
</tr>
</tbody>
</table>
<p>This is useful information printed to the screen, we see sample size, names of objects and their classes, and the first ten observations as examples. Obviously, this is not the data itself, but some sort of summary. It would be a complete disaster, if R would pass this information on when the call is part of an assignment or other operation on the data, for example: <code>NewExp &lt;- Experiment</code>. Apparently, R is aware of whether a called object is part of an operation, or purely for the programmers eyes. For any object, if <em>called to the console in an intercative session</em>, R silently uses the <code>print</code> function on the object. The following would give precisely the same results as above.</p>
<p>Such <code>print</code> functions exist for dozens of classes of objects. They represent what the developers thought would be the most salient or logical thing to print in an interactive session. By virtue of the object system, R finds the right print function for the object at hand.</p>
<p>However, when working interactively, most of the time you do a data transformation and assign it to a new variable, thus you check it immediately. As the assignment is always silent (unless there occurs an error), you are forced to type a print statement afterwards. There is shortcut for that: if you embrace the assignment statement in brackets, the result will be printed to the screen. As convenient as this is, especially when creating longer data transformation chains, it introduces some visual clutter. In this book I use it sparingly, at most.</p>
<p>The dedicated print function does what way back a developer thought would be the most useful information in most cases. Depending on the situation, it can provide too much, too little or just the wrong information. For example: when simulating a data set, like in [First Exercise], we want to check whether the resulting data frame has the desired length and whether the variables have the correct class. The standard implementation of the print command, dumps the whole data frame to the screen, which can be much more than ever needed. The newer dplyr implementation <code>data_frame</code> (from the tidyverse, also called <em>tibble</em>) you have seen in action already, is much better suited for this situation, as it displays dimensions and variable classes. In contrast, if the job is to spot whether there are many missing values (<code>NA</code>), the classic print performs better.</p>
<p>Whatever the question is, several commands are available to look into a data frame from different perspectives. Another command that is implemented for a variety of classes is <code>summary</code>. For all data frames, it produces an overview with descriptive statistics for all variables (i.e. columns). Particularly useful for data initial screening, is that missing values are listed per variable.</p>
<pre><code>##     Group                age          outcome   
##  Length:100         Min.   :18.0   Min.   :188  
##  Class :character   1st Qu.:23.0   1st Qu.:210  
##  Mode  :character   Median :27.0   Median :228  
##                     Mean   :26.8   Mean   :231  
##                     3rd Qu.:32.0   3rd Qu.:252  
##                     Max.   :35.0   Max.   :275</code></pre>
<p>The <code>str</code> (structure) command works on any R object and displays the hierarchical structure (if there is one):</p>
<pre><code>## Classes &#39;tbl_df&#39;, &#39;tbl&#39; and &#39;data.frame&#39;:    100 obs. of  3 variables:
##  $ Group  : chr  &quot;control&quot; &quot;experimental&quot; &quot;control&quot; &quot;experimental&quot; ...
##  $ age    : num  21 20 21 19 27 21 33 34 24 18 ...
##  $ outcome: num  228 258 204 256 221 ...</code></pre>
<p>Data frames store variables, but statistical procedures operate on variables. We need ways of accessing and manipulating statistical variables and we will have plenty. First, recall that in R the basic object types are all vectors. You can store as many elements as you want in an object, as long as they are of the same class.</p>
<p>Internally, data frames are a collection of “vertical” vectors that are equally long. Being a collection of vectors, the variables of a data frame can be of different classes, like <code>character</code>, <code>factor</code> or <code>numeric</code>. In the most basic case, you want to calculate a statistic for a single variable out of a data frame. The <code>$</code> operator pulls the variable out as a vector:</p>
<pre><code>## [1] 231</code></pre>
<p>As data frames are rectangular structures, you can also access individual values by their addresses. The following commands call</p>
<ul>
<li>the first <em>outcome</em> measure</li>
<li>the first to third elements of <em>Group</em></li>
<li>the complete first row</li>
</ul>
<table>
<thead>
<tr class="header">
<th align="right">outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">228</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="right">age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">21</td>
</tr>
<tr class="even">
<td align="right">20</td>
</tr>
<tr class="odd">
<td align="right">21</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">Group</th>
<th align="right">age</th>
<th align="right">outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">control</td>
<td align="right">21</td>
<td align="right">228</td>
</tr>
</tbody>
</table>
<p>Addressing one or more elements in square brackets, always requires two elements, first the row, second the column. As odd as it looks, one or both elements can be empty, which just means: get all rows (or all columns). Even the expression <code>Experiment[,]</code> is fully valid and will just the return the whole data frame.</p>
<p>There is an important difference, however, when using R’s classic <code>data.frame</code> as compared to dplyr’s <code>data_frame</code>implementation: When using single square brackets on dplyr data frames one always gets a data frame back. That is a very predictable behavior, and very much unlike the classic: with <code>data.frame</code>, when the addressed elements expand over multiple columns, like
<code>Experiment[, 1:2]</code>, the result will be a <code>data.frame</code> object, too. However, when slicing a single column, the result is a vector:</p>
<table>
<thead>
<tr class="header">
<th align="left">Group</th>
<th align="right">age</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">control</td>
<td align="right">21</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">20</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr class="header">
<th align="left">Group</th>
<th align="right">age</th>
<th align="right">outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">control</td>
<td align="right">21</td>
<td align="right">228</td>
</tr>
</tbody>
</table>
<pre><code>##   [1] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##   [6] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [11] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [16] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [21] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [26] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [31] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [36] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [41] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [46] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [51] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [56] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [61] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [66] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [71] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [76] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [81] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [86] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;
##  [91] &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;     
##  [96] &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot; &quot;control&quot;      &quot;experimental&quot;</code></pre>
<p>Predictability and a few other useful tweaks made me prefer <code>data_frame</code> over <code>data.frame</code>. But, many third-party packages continue to produce classic <code>data.frame</code> objects. For example, there is an alternative to package `<code>readxl</code>, <code>openxlsx</code>, which reads (and writes) Excel files. It returns classic data.frames, which can easily be converted as follows:</p>
<p>While <code>data_frame[]</code> behaves perfectly predictable, in that it always returns a data frame, even when this is just a single column or cell. Sometimes, one wants to truly extract a vector. With a <code>data_frame</code> a single column can be extracted as a vector, using double square brackets, or using the <code>$</code> operator.</p>
<p>Sometimes, it may be necessary to change values in a data frame. For example, a few outliers have been discovered during data screening, and the researcher decides to mark them as missing values. The syntax for indexing elements in a data frame can be used in conjunction with the assignment operator <code>&lt;-</code>. In the example below, we make the simulated experiment more realistic by injecting a few outliers. Then we discard these outliers by setting them all to <code>NA</code>.</p>
<table>
<thead>
<tr class="header">
<th align="left">Group</th>
<th align="right">age</th>
<th align="right">outcome</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">control</td>
<td align="right">-99</td>
<td align="right">228</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">20</td>
<td align="right">660</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">-99</td>
<td align="right">204</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">19</td>
<td align="right">256</td>
</tr>
<tr class="odd">
<td align="left">control</td>
<td align="right">27</td>
<td align="right">221</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">21</td>
<td align="right">987</td>
</tr>
</tbody>
</table>
<p>Besides the injection, note two more features of addressing data frame elements. The first is, that vectors can be used to address multiple rows, e.g. 2 and 6. In fact, the range operator <code>1:3</code> we used above is just a convenient way of creating a vector <code>c(1,2,3)</code>. Although not shown in the example, this works for columns alike.</p>
<p>The careful reader may also have noted another oddity in the above example. With <code>Experiment[c(2, 6),"outcome"]</code> we addressed two elements, but right-hand side of <code>&lt;-</code> is only one value. That is a basic mechanism of R, called <em>reuse</em>. When the left-hand side is longer than the right-hand side, the right-hand side is reused as many times as needed. Many basic functions in R work like this, and it can be quite useful. <!-- #12 --> For example, you may want to create a vector of 20 random numbers, where one half has a different mean as the second half of observations.</p>
<p>The above example reuses the two mean values 50 times, creating an alternating pattern. Strictly speaking, the <code>sd = 1</code> parameter is reused, too, a 100 times. While reuse often comes in convenient, it can also lead to difficult programming errors. So, it is a good advice to be aware of this mechanism and always carefully check the input to vectorized functions.</p>
</div>
<div id="import-export-and-archiving" class="section level3">
<h3><span class="header-section-number">3.2.6</span> Import, export and archiving</h3>
<p>R lets you import data from almost every conceivable source, given that you have installed and loaded the appropriate packages (foreign, haven or openxlsx for Excel files). Besides that R has its own file format for storing data, which is <em>.Rda</em> files. With these files you can save data frames (and any other object in R), using the <code>save(data, file = "some_file.Rda")</code> and <code>load(file = "some_file.Rda")</code> commands.</p>
<p>Few people create their data tables directly in R, but have legacy data sets in Excel (<em>.xslx</em>) and SPSS files (<em>.sav</em>). Moreover, the data can be produced by electronic measurement devices (e.g. electrodermal response measures) or programmed experiments can provide data in different forms, for example as <em>.csv</em> (comma-separated-values) files. All these files can be opened by the following commands:</p>
<p>Note that I gave two options for reading SPSS files. The first (with an underscore) is from the newer haven package (part of tidyverse). With some SPSS files, I experienced problems with this command, as it does not convert SPSS’s data type <em>labelled</em> (which is almost the same as an R factor). The alternative is the classic <code>read.spss</code> command which works almost always, but as a default it creates a list of lists, which is not what you typically want. With the extra argument, as shown, it behaves as expected.</p>
<p>Remember, data frames are objects and volatile as such. If you leave your session, they are gone. Once you have you data frame imported and cleaned, you may want to store it to a file. Like for reading, many commands are available for writing all kinds of data formats. If you are lucky to have a complete R-based workflow, you can conveniently use R’s own format for storing data, <code>Rdata</code> files. For storing a data frame and then reading it back in (in your next session), simply do:</p>
<p>Note that with <code>save</code> and <code>load</code> all objects are restored by their original names, without using any assignments. Take care, as this will not overwrite any object with the same name. Another issue is that for the <code>save</code> command you have to explicitly refer to the <code>file</code> argument and provide the file path as a character object. In Rstudio, begin typing <code>file=""</code>, put the cursor between the quotation marks and hit <code>Tab</code>, which opens a small dialogue for navigation to the desired directory.</p>
<p>Once you have loaded, prepared and started to analyze a data frame in R, there is little reason to go back to any legacy program. Still, the <code>haven</code> and <code>foreign</code> packages contain commands to write to various file formats. I’ll keep that as an exercise to the reader.</p>
</div>
<div id="case-environments" class="section level3">
<h3><span class="header-section-number">3.2.7</span> Case environments</h3>
<p>This book features more than a dozen case studies. Every case will be encountered several times and multiple objects are created along the way: data sets, regressions, graphics, tables, you name it. That posed the problem of naming the objects, so that they are unique. I could have chosen object names, like: <code>BrowsingAB_M_1</code>, <code>AUP_M_1</code>, etc. But, this is not what you normally would do, when working on one study at a time. Moreover, every letter you add to a line of code makes it more prone to errors and less likely that you, dear reader, are typing it in and trying it out yourself.</p>
<p>For these reasons, all cases are enclosed in <em>case environments</em> and provided with this book. For getting a case environment to work in your session, it has to be loaded from the respective R data file first:</p>
<p>In R, <em>environments</em> are containers for collections of objects. If an object <code>BAB1</code> is placed in an environment <code>BrowsingAB</code>, it can be called as <code>BrowsingAB$BAB1</code>. This way, no brevity is gained. Another way to assess objects in an environment is to <em>attach the environment first</em> as:</p>
<p>Calling <code>attach</code> gets you into the <em>namespace</em> of the environment (formally correct: the namespace gets imported to your working environment). All objects in that namespace become immediately visible by their mere name. The <code>detach</code> command leaves the environment, again. When working with the case environments, I strongly recommend to detach before attaching another environment.</p>
<p>All case environments provided with this book contain one or more data sets. Many of the cases are synthetic data which has been generated by a simulation function. This function, routinely called <code>simulate</code>, is provided with the case environment, too. That gives you the freedom to produce your own data sets with the same structure, but different effects.
Generally, calling the simulation function without any further arguments, exactly reproduces the synthetic data set provided with the case environment.</p>
<p>Furthermore, once you delve deeper into R, you can critically inspect the simulation function’s code for its behavioral and psychological assumptions (working through the later chapters on data management and simulation will help).</p>
<pre><code>## function(N = 40,
##            beta = c(Intercpt = 60, 
##                     fnt_size_12 = -12, 
##                     fnt_color_blk = -10, 
##                     ia_blk_12 = 8),
##            sigma = 5,
##            seed = 42) 
##     {
##     set.seed(seed)
##     out &lt;-
##       tibble(Part = 1:N,
##                  font_size = factor(rep(c(1, 2), N/2), 
##                                     levels = c(1,2), 
##                                     labels = c(&quot;10pt&quot;, &quot;12pt&quot;)),
##                  font_color = factor(c(rep(1, N/2), rep(2, N/2)),
##                                      levels = c(1,2), 
##                                      labels = c(&quot;gray&quot;, &quot;black&quot;))) %&gt;%
##        mutate( mu = beta[1] + 
##                 beta[2] * (font_size == &quot;12pt&quot;) +
##                 beta[3] * (font_color == &quot;black&quot;) +
##                 beta[4] * (font_color == &quot;black&quot;) * (font_size == &quot;12pt&quot;),
##               ToT = rnorm(N,  mu, sigma)) %&gt;% 
##     as_tbl_obs()
##     
##     #class(out) &lt;- append(class(out), &quot;sim_tbl&quot;)
##     attr(out, &quot;coef&quot;) &lt;- list(beta = beta,
##                               sigma = sigma)
##     attr(out, &quot;seed&quot;) &lt;- seed
##     
##     out %&gt;% as_tbl_obs()
##     }
## &lt;bytecode: 0x000000002e5c4670&gt;</code></pre>
<p>Finally, the case environments contain all objects that have been created throughout this book. This is especially useful for the regression models, as fitting these can take from a few seconds to hours.</p>
<p>Note that working with environments is a tricky business. Creating these case environments in an efficient way was more difficult than you may think. Therefore, I do <em>not</em> recommend using environments in everday data analysis, with one exception: at any moment the current working environment contains all objects that have been created, so far. That is precisely the set of objects shown in the Environment pane of Rstudio (or call <code>ls()</code> for a listing). Saving all objects and retrieving them when returning from a break is as easy as:<!-- #13 --></p>
<p>Next to that, Rstudio can be configured to save the current workspace on exit and reload it on the next start. When working on just one data analysis for a longer period of time, this can be a good choice.</p>
</div>
<div id="structuring-data" class="section level3">
<h3><span class="header-section-number">3.2.8</span> Structuring data</h3>
<p>In the whole book, data sets are structured according to the rule <em>one-row-per-observation of the dependent variable</em> (the ORPO rule). Many researchers still organize their data tables as one-row-per-participant, as is requested by some legacy statistics programs. This is fine in research with non-repeated measures, but will not function properly with modern regression models, like linear mixed-effects models. Consider a study where two designs were evaluated by three participants using a self-report item, like “how easy to use is the interface?” Then, the <em>wrong way</em> of structuring the data would be:</p>
<p>The correct way of setting up the data frame is:</p>
<table>
<thead>
<tr class="header">
<th align="right">Part</th>
<th align="left">Design</th>
<th align="right">response</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="left">A</td>
<td align="right">4</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="left">A</td>
<td align="right">4</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="left">A</td>
<td align="right">6</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="left">B</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="left">B</td>
<td align="right">4</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="left">B</td>
<td align="right">3</td>
</tr>
</tbody>
</table>
<p>The ORPO rule dictates another principle: every row should have a unique identifier, which can be a combination of values. In the example above, every observation is uniquely identified by the participant identifier and the design condition. If we extend the example slightly, it is immediatly apparent, why the ORPO rule is justified. Imagine, the study actually asked three partcipants to rate two different tasks on two different designs by three self-report items. By the ORPO rule, we can easily extend the data frame as below (showing a random selection of rows). I leave it up to the reader to figure out how to press such a data set in the wide legacy format.</p>
<p>Using identifiers is good practice for several reasons. First, it reduces problems during manual data entry. Second, it allows to efficiently record data in multi-method experiments and join them automatically. This is shown in chapter [DM]. Lastly, the identifiers will become statistically interesting by themselves when we turn to linear mixed-effects models and the notion of <em>members of a population</em>. Throughout the book I will use standard names for recurring identifier variables in design research:</p>
<ul>
<li>Part</li>
<li>Design</li>
<li>Item</li>
<li>Task</li>
</ul>
<p>Note that usually these entities get numerical identifiers, but these numbers are just labels. Throughout, variables are written Uppercase when they are entities, but not real numbers. An exception is the trial order in experiments with massive repeated measures. These get a numerical type to allow exploring effects over time such as learning, training and fatigue.</p>
<table>
<thead>
<tr class="header">
<th align="right">Part</th>
<th align="right">Task</th>
<th align="left">Design</th>
<th align="right">Item</th>
<th align="right">response</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="left">B</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">2</td>
<td align="left">B</td>
<td align="right">1</td>
<td align="right">6</td>
</tr>
<tr class="odd">
<td align="right">2</td>
<td align="right">1</td>
<td align="left">B</td>
<td align="right">3</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td align="right">2</td>
<td align="right">2</td>
<td align="left">B</td>
<td align="right">2</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td align="right">3</td>
<td align="right">2</td>
<td align="left">A</td>
<td align="right">2</td>
<td align="right">6</td>
</tr>
<tr class="even">
<td align="right">3</td>
<td align="right">2</td>
<td align="left">B</td>
<td align="right">2</td>
<td align="right">4</td>
</tr>
</tbody>
</table>
</div>
<div id="data-transformation" class="section level3">
<h3><span class="header-section-number">3.2.9</span> Data transformation</h3>
<p>Do you wonder about the strange use of <code>%&gt;%</code> in my code above? This is the tidy way of programming data transformations in R.</p>
<p>The so-called magritte operator <code>%&gt;%</code> is part of the <em>dplyr/tidyr</em> framework for data manipulation. It chains steps of data manipulation by connecting transformation functions, also called piping. In the following, we will first see a few basic examples. Later, we will proceed to longer transformation chains and see how graceful dplyr piping is, compared to the classic data transformation syntax in R.</p>
<p>Importing data from any of the possible resources, will typically give a data frame. However, often the researcher wants to <em>select</em> or <em>rename</em> variables in the data frame. Say, you want the variable <em>Group</em> to be called <em>Condition</em>, omit the variable <em>age</em> and store the new data frame as <em>Exp</em>. The <code>select</code> command does all this. In the following code the data frame <code>Experiment</code> is piped into <code>select</code>. The variable <em>Condition</em> is renamed to <em>Group</em>, and the variable <em>outcome</em> is taken as-is. All other variables are discarded.</p>
<p>Another frequent step in data analysis is cleaning the data from missing values and outliers. In the following code example, we first “inject” a few missing values for age (which were coded as -99) and outliers (&gt;500) in the outcome variable. Note that I am using some R commands that you don’t need to understand by now. Then we reuse the above code for renaming (this time keeping <em>age</em> on board) and add some filtering steps:</p>
<p>During data preparation and analysis, new variables are created routinely. For example, the covariate is often shifted to the center before using linear regression:</p>
<p>Finally, for the descriptive statistics part of your report, you probably want to summarize the outcome variable per experimental condition. The following chain of commands first groups the data frame, then computes means and standard deviations. At every step, a data frame is piped into another command, which processes the data frame and outputs a data frame.</p>
<table>
<thead>
<tr class="header">
<th align="left">Condition</th>
<th align="right">mean</th>
<th align="right">sd</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">control</td>
<td align="right">210</td>
<td align="right">8.99</td>
</tr>
<tr class="even">
<td align="left">experimental</td>
<td align="right">252</td>
<td align="right">12.19</td>
</tr>
</tbody>
</table>
</div>
<div id="plotting-data" class="section level3">
<h3><span class="header-section-number">3.2.10</span> Plotting data</h3>
<p>Good statistical graphics can vastly improve your and your readers understanding of data and results. This book exclusively introduces the modern ggplot2 graphics system of R, which is based on the <a href="http://zevross.com/blog/2014/08/04/beautiful-plotting-in-r-a-ggplot2-cheatsheet-3/">grammar of graphics</a>.</p>
<p>Every plot starts with piping a data frame into the <code>ggplot(aes(...))</code> command. The <code>aes(...)</code> argument of ggplot creates the <em>aesthetics</em>, which is a <em>mapping between variables and features of the plot</em> (and only remotely has something to do with beauty). Review the code once again that produces the piles-of-sugar: the aesthetics map the variable <em>Group</em> on the fill color, whereas <em>outcome</em> is mapped to the x axis. For a plot to be valid, there must at least one layer with a <em>geometry</em>. The above example uses the density geometry, which calculates the density and maps it to the y axis.</p>
<p>The ggplot2 plotting system knows a full set of geometries, like:</p>
<ul>
<li>scatter plots with <code>geom_point()</code></li>
<li>smooth line plots with <code>geom_smooth()</code></li>
<li>histograms with <code>geom_histogram()</code></li>
<li>box plots with <code>geom_boxplot()</code> and</li>
<li>my personal favorite: horizontal density diagrams with <code>geom_violin()</code></li>
</ul>
<p>For a brief demonstration of ggplots basic functionality, we use the <code>BAB1</code> data set of the BrowsingAB case. We attach the case environment and use the <code>str</code> command to take a first look at the data:</p>
<p>The BrowsingAB case is a virtual series of studies, where two websites were compared by how long it takes users to complete a given task, time-on-task (ToT). Besides the design factor, a number of additional variables exist, that could possibly play a role for ToT, too. We explore the data set with ggplot:</p>
<p>We begin with a plot that shows the association between age of the participant and ToT. Both variables are metric and suggest themselves to be put on a 2D plane, with coordinates x and y, a <em>scatter plot</em>.</p>
<p><img src="Getting_started_with_R_files/figure-html/build_ggpl_2-1.png" width="66%"  /></p>
<p>Let’s take a look at the elements of the command chain: The first two lines pipe the data frame into the ggplot engine.</p>
<p>At that moment, the ggplot engine “knows” which variables the data frame contains and hence are available for the plot. It does not yet know, which variables are being used, and how. The next step is, usually, to consider a basic (there exist more than 30) <em>geometry</em> and put it on a <em>layer</em>. The scatter plot geometry of ggplot is <code>geom_point</code>:</p>
<p>The last step is the <em>aesthetic mapping</em>, which tells ggplot the variables to use and how to map them to <em>aesthetic</em> properties of the geometry. The basic properties of points in a coordinate system are the x and y-positions:</p>
<p>The function <code>aes</code> creates a mapping where the aesthetics per variable are given. When call <code>aes</code> directly, we see that it is just a table.</p>
<pre><code>## Aesthetic mapping: 
## * `x` -&gt; `age`
## * `y` -&gt; `ToT`</code></pre>
<p>One tiny detail in the above chain has not yet been explained: the <code>+</code>. When choosing the geometry, you actually <em>add a layer</em> to the plot. This is, of course, not the literal mathematical sum. Technically, what the author of the ggplot2 package did, was to <em>overload</em> the <code>+</code> operator. A large set of ggplot functions can be combined in a myriad of ways, just using <code>+</code>. The overloaded <code>+</code> in ggplot is a brilliant analogy: you can infinitely chain ggplot functions, like you can create long sums. You can store ggplot object and later modify it by adding functions. The analogy has its limits, though: other than sums, order matters in ggplot combinations: the first in the chain is always <code>ggplot</code> and layers are drawn upon each other.</p>
<p>Let’s move on with a slightly different situation that will result in a different geometry. Say, we are interested in the distribution of the time-on-task measures under the two designs. We need a geometry, that visualizes the distribution of quantitative variables split by a grouping variable, factor. The box plot does the job:</p>
<p><img src="Getting_started_with_R_files/figure-html/unnamed-chunk-32-1.png" width="66%"  /></p>
<p>The box plot maps ToT to y (again). The factor Design is represented as a split on the x-axis. Interestingly, the box plot does not represent the data as raw as in the scatter plot example. The geometry actually performs an analysis on ToT, which produces five statistics: min, first quartile, median, third quartile and max. These statistics define the vertical positions of bars and end points.</p>
<p>Now, we combine all three variables in one plot: how does the association between ToT and age differ by design? As we have two quantitative variables, we stay with the scatter plot for now. As we intend to separate the groups, we need a property of points to distinguish them. Points offer several additional aesthetics, such as color, size and shape. We choose color, and add it to the aesthetic mapping by <code>aes</code>. Note, that it does not matter whether you use the British or American way of writing (colour vs. color).</p>
<p><img src="Getting_started_with_R_files/figure-html/unnamed-chunk-33-1.png" width="66%"  /></p>
<p>Now, we can distinguish the groups visually, but there is too much clutter to discover any relation. With the box plot we saw that some geometries do not represent the raw data, but summaries (statistics) of data. For scatter plots, a geometry that does the job of summarizing the trend is <code>geom_smooth</code>. This geometry summarizes a cloud of points by drawing a LOESS-smooth line through it. Note how the color mapping is applied to all geometry layers.</p>
<p><img src="Getting_started_with_R_files/figure-html/unnamed-chunk-34-1.png" width="66%"  /></p>
<p>We see a highly interesting pattern: the association between age and ToT follows two slightly different mirrored sigmoid curves.</p>
<p>Now that we have represented three variables with properties of geometries, what if we wanted to add a fourth one, say education level? Formally, we could use another aesthetic, say shape of points, to represent it. You can easily imagine that this would no longer result in a clear visual figure. For situations, where there are many factors, or factors with many levels, it is impossible to reasonably represent them in one plot. The alternative is to use <em>facetting</em>. A facet splits the data by a grouping variable and creates one single plot for every group:</p>
<p><img src="Getting_started_with_R_files/figure-html/unnamed-chunk-35-1.png" width="66%"  /></p>
<p>See, how the <code>facet_grid</code> command takes a formula, instead of just a variable name. This makes faceting the primary choice for highly-dimensional situations. For example, we may also choose to represent both factors, Design and education by facets:</p>
<p><img src="Getting_started_with_R_files/figure-html/unnamed-chunk-36-1.png" width="66%"  /></p>
<p>Note how the color aesthetic, although unnecessary, is kept. It is possible to map several aesthetics (or facets) to one variable, but not vice versa.</p>
</div>
<div id="fitting-regression-models" class="section level3">
<h3><span class="header-section-number">3.2.11</span> Fitting regression models</h3>
<p>Above we have seen examples of functions that boil down a vector to a single statistic, like the mean. R has several functions that summarize data in a more complex way. One function with a wide range of applications is the <code>lm</code> command, that applies regression models to data (provided as data frames).</p>
<p>In the following, we will use another simulated data frame <code>Exp</code> to demonstrate linear models. To make this more interesting, we simulate <code>Exp</code> in a slightly advanced way, with quantitative associations between variables. Note how the <em>expected value</em> <span class="math inline">\(\mu\)</span> is created by drawing on the variables <code>Condition</code> and <code>age</code>. The last step adds (somewhat) realistic noise to the measures, by drawing from the normal distribution with a mean of <span class="math inline">\(mu\)</span>.</p>
<p>The experiment involves two groups, which in classic statistics would clearly point to what is commonly referred to as <em>ANOVA</em>. As it will turn out in [LM], old-fashioned ANOVA can be replaced by a rather simple regression model, that I call comparison of groups model (CGM). The estimation of regression models is done by a <em>regression engine</em>, which basically is a (very powerful) R command. The specification for any regression model is given in R’s formula language. Learning this formula language is key to unleashing the power of regression models in R. We can perform a CGM on the data frame <code>Exp</code> using the regression engine <code>stan_glm</code>. The desired model estimates the effect of <code>Condition</code> on <code>outcome</code>. This produces a regression object that contains an abundance of information, much of it is of little interest for now. (A piece of information, that it does <em>not</em> contain is F-statistics and p-values; and that is why it is not an ANOVA, strictly speaking!) The foremost question is how strong the difference between the groups is. The <code>fixef</code> command extracts the parameter estimates from the model to answer the question.</p>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">275.4</td>
<td align="right">264.0</td>
<td align="right">286.2</td>
</tr>
<tr class="even">
<td align="left">ConditionExperimental</td>
<td align="right">-47.5</td>
<td align="right">-62.6</td>
<td align="right">-31.9</td>
</tr>
</tbody>
</table>
<p>Another classic model is <em>linear regression</em>, where outcome is predicted by a metric variable, say <code>age</code>. The <code>stan_glm</code> regression engine is truly multi-purpose and does the job with grace:</p>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">219.02</td>
<td align="right">133.51</td>
<td align="right">308.60</td>
</tr>
<tr class="even">
<td align="left">age</td>
<td align="right">1.16</td>
<td align="right">-1.98</td>
<td align="right">4.18</td>
</tr>
</tbody>
</table>
<p>If you are interested in both at the same time, you can combine that in one model by the following formula:</p>
<table>
<thead>
<tr class="header">
<th align="left">fixef</th>
<th align="right">center</th>
<th align="right">lower</th>
<th align="right">upper</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">Intercept</td>
<td align="right">219.72</td>
<td align="right">177.280</td>
<td align="right">261.59</td>
</tr>
<tr class="even">
<td align="left">ConditionExperimental</td>
<td align="right">-50.35</td>
<td align="right">-63.763</td>
<td align="right">-36.38</td>
</tr>
<tr class="odd">
<td align="left">age</td>
<td align="right">2.01</td>
<td align="right">0.557</td>
<td align="right">3.52</td>
</tr>
</tbody>
</table>
<p>A statistical model has several components, for example the coefficients and residuals. Models are complex objects, from which a variety of inferences can be made. For example, the coefficient estimates can be extracted and used for prediction. This is what <code>fixef()</code> does in the above code.</p>
<p>A number of functions can be used to extract certain aspects of the model. For example:</p>
<ul>
<li><code>fixef(model)</code> extracts the linear effects</li>
<li><code>residuals(model)</code> extracts the measurement errors</li>
<li><code>predict(model)</code> extracts the expected values</li>
</ul>
<p>These will all be covered in later chapters.</p>
</div>
<div id="knitting-statistical-reports" class="section level3">
<h3><span class="header-section-number">3.2.12</span> Knitting statistical reports</h3>
<p>As you have seen throughout this chapter, with R you can effectively manage data, create impressively expressive graphics and conveniently estimate statistical models. Then usually comes the painful moment where all this needs to be assembled into a neat report. With R and Rstudio it has never been easier than that. In fact, complete books have been written in R, like the one you are reading.</p>
<p>A <em>minimal statistical report</em> contains four elements:</p>
<ol style="list-style-type: decimal">
<li>a recap of the research question</li>
<li>description of how the statistical model relates to the research question</li>
<li>a few figures or tables that answers the research question</li>
<li>an explanation of the results</li>
</ol>
<p>Of these four elements, three are pure text. For a minimal report it is a fairly convenient to use a word processor software for the text, craft the figure in R and copy it. One problem with this approach is that a <em>scrunitable statistical report</em> contains at least the following <em>additional</em> elements:</p>
<ol style="list-style-type: decimal">
<li>procedures of data preparation (sources, transformations, variable names, outlier removal)</li>
<li>data exploration (ranges of variables, outlier discovery, visualizing associations, etc.)</li>
<li>model estimation (formula specification, convergence checks)</li>
<li>model criticism (normality of residuals, etc.)</li>
</ol>
<p>In advanced statistical workflows this is then multiplied by the number of models, an iterative selection process. Because it is easy to lie with statistics, these elements are needed as to build a fundament of credibility. Full transparency is achieved, when another researcher can exactly reproduce all steps of the original analysis. It is obvious that the easiest way to achieve this, is to hand over the full R script.</p>
<p>The most user-friendly way to achieve both, a good looking report and full transparency, is to write a document that contains all before mentioned: text, graphics, tables and R code. In the R environment such mixed documents can be written in the <em>markdown/knitr</em> framework.</p>
<p>Markdown implements a simple markup language, with that you can typset simple, structured texts in a plain ASCII editor. Later in the workflow, such a markup document is transformed into one of various output formats, that are rendered by the respective programs, such as Microsoft Word or an HTML browser.</p>
<div class="figure">
<img src="Illustrations/markup_minimal_report.png" alt="A minimal statistical report in markdown" />
<p class="caption">A minimal statistical report in markdown</p>
</div>
<p>The above text is an alternation of markup text and <em>chunks</em>, those weirdly enclosed pieces of R code. While the text is static, the chunks are processed by the knitr engine, evaluating the enclosed R code and knitting the output into a document. Very conveniently, when the output is a figure, it will be inserted into the document right away. The <code>kable</code> command from the knitr package, in turn, produces neatly rendered tables from data frame objects. By default, the R code is shown, too, but that can be customized.</p>
<p>The minimal workflow for statistical reporting with knitr is as follows:</p>
<ol style="list-style-type: decimal">
<li>Use markdown right away, covering all steps of your data analysis, i.e. a scrutable report. You may even start writing when only one part of your data gathering is completed, because due to the dynamic chunks, updating the report when new data arrives is just a button click away.</li>
<li>When the data analysis is complete, compile the scrutable report to Word format</li>
<li>Extract the passages, figures and tables for a minimal statistical report. This is your results section.</li>
<li>provide the scrutable report as appendix or supplementary material</li>
</ol>
<p>In the notion of this chapter, this is just to get you started and knitr is so tightly integrated with the Rstudio environment that I don’t even bother to explain the commands for knitting a document. Once acquainted with the basics, markdown provides a few additional markup tokens, like footnotes, hyperlinks or including images. The customization options and addons for knitr are almost endless and various interesting addons are available, just to mention two:</p>
<ol style="list-style-type: decimal">
<li>The bookdown package provides an infrastructure for writing and publishing longer reports and books.</li>
<li>With the shiny package one can add dynamic widgets to HTML reports. Think of a case, where your statistical model is more complicated than a linear regression line or a few group means, say you are estimating a polynomial model or a learning curve. Then, with a simple shiny app, you can enable your readers to understand the model by playful exploration.</li>
</ol>
</div>
<div id="exercises" class="section level3">
<h3><span class="header-section-number">3.2.13</span> Exercises</h3>
<ol style="list-style-type: decimal">
<li><p>In the book package (directory <code>/Data</code>) you will find the data set of the (virtual) study BAB1, which we will be using in coming chapters. This data comes as comma-separated value file with the file ending <code>.csv</code>. Load this file into R using the <code>read_csv</code> command and check the dataframe.</p></li>
<li><p>Find the documentation of the packages <code>haven</code> and <code>readr</code>. Find two import functions. The one that is most useful for you and the one that you consider most exotic.</p></li>
<li><p>We have seen how to extract a data frame column as a vector using the double square brackets. There seems to be no such option to extract an individual row as a vector. Why? (Think about object types). &lt;–! #14 –&gt;</p></li>
<li><p>Use the world wide web to find geometries that are useful for plotting associations between grouping variables (factors) and a metric variables. Try them all on the BAB1 data frame. Compare the geometries on what properties of the data they convey.</p></li>
<li><p>Like data frames and regression results, plots produced by ggplot are complex objects, too. Create an arbitrary plot, store it in a variable and inspect it using <code>class</code>, <code>summary</code> and <code>str</code>. In addition, what happens when you assign the plot to a variable and what happens when you call the variable?</p></li>
<li><p>Revisit the python-swallowed-camel plot and check out how the aesthetic mapping is created. The plot uses a density geometry. Change it into a histogram. Then produce a box plot that shows the two conditions (think carefully about the mappings of x and y).</p></li>
<li><p>Use the data set BAB5 in BrowsingAB. It contains a follow-up experiment, where participants had to do five different tasks on the website. Plot the association between age and ToT by task, using color. Then put Task on a facet grid, and use color to represent Design again.</p></li>
<li><p>Use the data set BAB5 in BrowsingAB. Using a transformation chain, take the sum or average of participants’ ToT. Then run a few simple regression models.</p></li>
<li><p>Use your own data. Drop an Excel and/or an SPSS file into the same directory as your current R file. Read the data into a data frame and summarize what is in the data frame. Use ggplot to create one or more exploratory graphs. Then use dplyr <code>summarize</code> to create summary statistics.</p></li>
<li>Do a full exploratory analysis of the dataframe D_agg in case environment IPump. It has the predictors Design, Group, Education and experience. It has the outcome variables ToT, deviations and workload.
<ol style="list-style-type: decimal">
<li>Get the data frame into R and produce a summary.</li>
<li>Plot a histogram for all dependent variables.</li>
<li>Produce a table that counts the number of observations per Education(al level).</li>
<li>Produce a table that displays minimum, maximum, median, mean and standard deviation of experience.</li>
<li>Exclude participants with less than four years of experience.</li>
<li>Produce a table with group means per Design and Session.</li>
<li>For every outcome variable, produce a plot for Design by session.</li>
<li>Explore graphically, what other relations may exist between outcome variables and Group, Education and experience.</li>
<li>Run a regression model for ToT with Design and Session as predictors.</li>
<li>Produce a coefficient table.</li>
<li>Plot the residuals.</li>
</ol></li>
</ol>
</div>
<div id="bibliographic-notes-1" class="section level3">
<h3><span class="header-section-number">3.2.14</span> Bibliographic notes</h3>
<p><a href="http://r4ds.had.co.nz/">R for Data Science</a> is a book co-authored by Hadley “Tidy” Wickham.</p>
<p><a href="http://www.r-bloggers.com/ggplot2-version-of-figures-in-%E2%80%9C25-recipes-for-getting-started-with-r%E2%80%9D/">ggplot2 Version of Figures in “25 Recipes for Getting Started with R”</a> for readers who are familiar with the legacy plotting commands in R.</p>
<p><a href="http://rpubs.com/justmarkham/dplyr-tutorial">Introduction to dplyr for Faster Data Manipulation in R</a> introduces dplyr, the next generation R interface for data manipulation, which is used extensively in this book.</p>
<p><a href="http://www.statmethods.net/">Quick-R</a> is a comprehensive introduction to many common statistical techniques with R.</p>
<p><a href="http://codeasmanuscript.org/lessons/">Code as manuscript</a> features a small set of lessons with code examples, assignments and further resources. For if you are in a haste.</p>
<p><a href="https://bookdown.org/yihui/bookdown/">bookdown: Authoring Books and Technical Documents with R Markdown</a> fully unleashes the power of knitr for writing and publishing longer reports and books.</p>

</div>
</div>
<!-- </div> -->
<p style="text-align: center;">
<a href="3-1-setting-up-the-r-environment.html"><button class="btn btn-default">Previous</button></a>
</p>
</div>
</div>



</body>
</html>
